<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Catagotchi</title>
    <meta name="theme-color" content="#ff85c5">
    <link rel="manifest" href="manifest.webmanifest">
    <link rel="icon" type="image/png" href="icons/caticon/icon.png">
    <link rel="apple-touch-icon" href="icons/caticon/icon.png">
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
            -webkit-touch-callout: none;
            touch-action: manipulation;
        }

        @keyframes bubbleFloat {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-6px); }
        }

        @keyframes bubbleWiggle {
            0%, 100% { transform: rotate(-4deg) scale(1); }
            50% { transform: rotate(4deg) scale(1.05); }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        const GAME_DEFINITIONS = [
          {
            id: 'flappy-lukis',
            title: 'Flappy Lukis',
            emoji: 'üêæ',
            description: 'Ayuda a Lukis a volar entre las nubes sin chocarse.'
          },
          {
            id: 'lukis-sky-jump',
            title: 'Lukis Aventurero',
            emoji: 'ü™ú',
            description: 'Salta plataformas hacia el cielo como en Pou y llega lo m√°s alto posible.'
          },
          {
            id: 'lukis-treat-dash',
            title: 'Lukis Cazador',
            emoji: 'üç£',
            description: 'Desl√≠zate por el suelo para atrapar las golosinas que caen y esquiva los juguetes traviesos.'
          }
        ];

        const STORE_ITEMS = [
          {
            id: 'rainbow-sushi',
            name: 'Sushi arco√≠ris',
            emoji: 'üç£',
            type: 'food',
            price: 48,
            description: 'Rollitos brillantes rellenos de at√∫n m√°gico y crocante de estrellas.',
            effect: { hunger: 28, happiness: 12 }
          },
          {
            id: 'tacobell-crunch',
            name: 'Taco Bell supremo',
            emoji: 'üåÆ',
            type: 'food',
            price: 46,
            description: 'Crujiente, con queso extra y salsa lunar para un antojo nocturno.',
            effect: { hunger: 32, happiness: 10 }
          },
          {
            id: 'stardust-latte',
            name: 'Caf√© de Starbucks',
            image: 'tumblr_4015c40cad25a9236ccd49afae824e7e_12b5cf63_640.png',
            imageAlt: 'Vaso de caf√© helado de Starbucks con tapa verde',
            type: 'furniture',
            price: 44,
            description: 'Espuma celestial de vainilla con chispas que despiertan ronroneos.'
          },
          {
            id: 'burger-king-duo',
            name: 'Burger King 2x1',
            emoji: 'üçî',
            type: 'food',
            price: 62,
            description: 'Dos mega hamburguesas jugosas para compartir entre maullidos.',
            effect: { hunger: 46, happiness: 18 }
          },
          {
            id: 'labubu-plush',
            name: 'Labubu travieso',
            image: 'labubu-brown.png',
            imageAlt: 'Mu√±eco Labubu marr√≥n con cara traviesa',
            type: 'furniture',
            price: 72,
            description: 'Mu√±eco coleccionable que cuenta chismes felinos al apretarlo.'
          },
          {
            id: 'rainbow-mobile',
            name: 'Planetario flotante',
            emoji: 'ü™ê',
            type: 'furniture',
            price: 88,
            description: 'Planetas miniatura que orbitan sobre la habitaci√≥n con destellos suaves.'
          },
          {
            id: 'ugly-magnet',
            name: 'Im√°n feo',
            emoji: 'üß≤',
            image: 'iman-de-nevera-madrid-de-madera.png',
            imageAlt: 'Im√°n de madera de Madrid con forma de casa',
            type: 'furniture',
            price: 34,
            description: 'Un im√°n tan feo que da la vuelta completa a la nevera de la sala.'
          }
        ];

        const DECORATION_CONFIG = {
          'rainbow-mobile': {
            emoji: 'ü™ê',
            className: 'text-4xl animate-spin',
            style: { top: '18px', left: '24%' }
          },
          'stardust-latte': {
            image: 'tumblr_4015c40cad25a9236ccd49afae824e7e_12b5cf63_640.png',
            imageAlt: 'Vaso real de caf√© helado de Starbucks',
            className: 'drop-shadow-lg',
            imageClassName: 'h-16 w-16 object-cover rounded-xl',
            style: { bottom: '74px', left: '18%' }
          },
          'labubu-plush': {
            image: 'labubu-brown.png',
            imageAlt: 'Figura coleccionable Labubu color marr√≥n sentada',
            className: 'drop-shadow-xl',
            imageClassName: 'h-24 w-20 object-contain',
            style: { bottom: '68px', right: '24%' }
          },
          'ugly-magnet': {
            image: 'iman-de-nevera-madrid-de-madera.png',
            imageAlt: 'Im√°n de madera con la palabra Madrid',
            className: 'drop-shadow-md',
            imageClassName: 'h-14 w-14 object-contain',
            style: { top: '22px', right: '18%' }
          }
        };

        const DEFAULT_ECONOMY_STATE = { coins: 120, inventory: {}, decorations: [] };
        const ECONOMY_STORAGE_KEY = 'catagotchi-economy-v1';

        const loadEconomyState = () => {
          if (typeof window === 'undefined') {
            return { ...DEFAULT_ECONOMY_STATE };
          }
          try {
            const raw = window.localStorage.getItem(ECONOMY_STORAGE_KEY);
            if (!raw) {
              return { ...DEFAULT_ECONOMY_STATE };
            }
            const parsed = JSON.parse(raw);
            return {
              coins: Number.isFinite(parsed?.coins) ? parsed.coins : DEFAULT_ECONOMY_STATE.coins,
              inventory: parsed?.inventory && typeof parsed.inventory === 'object' ? parsed.inventory : {},
              decorations: Array.isArray(parsed?.decorations) ? parsed.decorations : []
            };
          } catch (error) {
            console.warn('No se pudo cargar la econom√≠a guardada', error);
            return { ...DEFAULT_ECONOMY_STATE };
          }
        };

        const computeMoodFromStats = (happiness, energy, hunger) => {
          if (happiness > 70 && energy > 70 && hunger > 70) return 'happy';
          if (happiness > 50 && energy > 50 && hunger > 50) return 'content';
          if (hunger < 30) return 'hungry';
          if (energy < 30) return 'tired';
          if (happiness < 30) return 'sad';
          return 'content';
        };

        const GameOverlay = ({ title, onClose, children }) => (
          <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-60 px-4">
            <div className="w-full max-w-md bg-white rounded-3xl shadow-2xl overflow-hidden">
              <div className="flex items-center justify-between px-5 py-4 bg-gradient-to-r from-purple-500 to-pink-500 text-white">
                <h2 className="text-lg font-semibold">{title}</h2>
                <button
                  onClick={onClose}
                  className="text-white/90 hover:text-white transition"
                  aria-label="Cerrar"
                >
                  ‚úñÔ∏è
                </button>
              </div>
              <div className="p-5 space-y-4 max-h-[70vh] overflow-y-auto">{children}</div>
            </div>
          </div>
        );

        const CAT_COLOR_PRESETS = {
          tuxedo: { body: 'bg-gray-900', chest: 'bg-white', ears: 'bg-gray-900' },
          gris: { body: 'bg-gray-400', chest: 'bg-white', ears: 'bg-gray-400' },
          siamese: { body: 'bg-yellow-100', face: 'bg-amber-800', ears: 'bg-amber-800' }
        };

        const CatAvatar = ({
          type,
          eyeColorClass,
          name,
          isSleeping = false,
          size = 64,
          className = '',
          style = {}
        }) => {
          const colors = CAT_COLOR_PRESETS[type] || CAT_COLOR_PRESETS.tuxedo;
          const resolvedEyeClass =
            eyeColorClass ||
            (type === 'siamese' ? 'bg-blue-500' : type === 'gris' ? 'bg-blue-400' : 'bg-green-400');
          const isHeartSmall = name === 'Lukis' || name === 'Arwen';
          const scale = size / 64;
          const faceClass = colors.face || colors.body;
          const chestClass = colors.chest || colors.body;
          const pawClass = type === 'siamese' ? 'bg-amber-800' : colors.body;

          return (
            <div
              className={`relative ${className}`}
              style={{ width: size, height: size, ...style }}
              aria-hidden="true"
            >
              <div
                className="absolute top-0 left-0"
                style={{
                  width: 64,
                  height: 64,
                  transform: `scale(${scale})`,
                  transformOrigin: 'top left'
                }}
              >
                <div className="relative w-16 h-16">
                  <div className={`absolute bottom-0 left-2 w-12 h-12 ${colors.body} rounded-full`}></div>
                  {(type === 'tuxedo' || type === 'gris') && (
                    <div className={`absolute bottom-1 left-4 w-8 h-9 ${chestClass} rounded-full`}></div>
                  )}
                  <div className={`absolute top-0 left-2 w-12 h-12 ${colors.body} rounded-full`}></div>
                  {type === 'siamese' ? (
                    <div className={`absolute top-1 left-3 w-10 h-9 ${faceClass} rounded-full`}></div>
                  ) : (
                    <div className="absolute top-1 left-3 w-10 h-9">
                      <svg
                        viewBox="0 0 100 100"
                        className="w-full h-full drop-shadow"
                        aria-hidden="true"
                        style={
                          isHeartSmall
                            ? {
                                transform: 'translateY(10%) scale(0.6)',
                                transformOrigin: 'center'
                              }
                            : undefined
                        }
                      >
                        <path
                          d="M50 15 C35 -5 0 0 0 30 C0 55 25 80 50 95 C75 80 100 55 100 30 C100 0 65 -5 50 15 Z"
                          fill="#ffffff"
                          transform="rotate(180 50 50)"
                        />
                      </svg>
                    </div>
                  )}
                  <div className={`absolute -top-1 left-3 w-4 h-5 ${colors.ears} rounded-full transform -rotate-12`}></div>
                  <div className={`absolute -top-1 right-3 w-4 h-5 ${colors.ears} rounded-full transform rotate-12`}></div>
                  <div className="absolute top-0 left-4 w-2 h-3 bg-pink-300 rounded-full transform -rotate-12"></div>
                  <div className="absolute top-0 right-4 w-2 h-3 bg-pink-300 rounded-full transform rotate-12"></div>
                  {isSleeping ? (
                    <>
                      <div className="absolute top-4 left-4 w-2 h-1 bg-gray-800 rounded-full"></div>
                      <div className="absolute top-4 right-4 w-2 h-1 bg-gray-800 rounded-full"></div>
                    </>
                  ) : (
                    <>
                      <div className={`absolute top-4 left-4 w-2 h-2 ${resolvedEyeClass} rounded-full`}></div>
                      <div className={`absolute top-4 right-4 w-2 h-2 ${resolvedEyeClass} rounded-full`}></div>
                    </>
                  )}
                  <div className="absolute top-5 left-1/2 transform -translate-x-1/2 w-1 h-1 bg-pink-400 rounded-full"></div>
                  <div className={`absolute -right-1 bottom-3 w-3 h-8 ${colors.body} rounded-full transform rotate-45`}></div>
                  <div className={`absolute bottom-0 left-3 w-1.5 h-4 ${pawClass} rounded-full`}></div>
                  <div className={`absolute bottom-0 right-3 w-1.5 h-4 ${pawClass} rounded-full`}></div>
                </div>
              </div>
            </div>
          );
        };

        const LukisOriginalAvatar = ({
          size = 64,
          className = '',
          style = {},
          overlay = true,
          imageClassName = ''
        }) => {
          const wrapperBase = overlay ? 'absolute inset-0' : 'relative';
          const imageBaseClass = overlay
            ? 'object-contain rounded-3xl shadow-lg'
            : 'object-cover rounded-2xl ring-2 ring-white/70';

          return (
            <div
              className={`${wrapperBase} pointer-events-none select-none flex items-center justify-center ${className}`}
              style={{ width: size, height: size, ...style }}
              aria-hidden={overlay}
            >
              <img
                src="IMG-20250924-WA0178.jpg"
                alt="Lukis cazando golosinas"
                className={`h-full w-full ${imageBaseClass} ${imageClassName}`}
              />
            </div>
          );
        };

        const GameMenu = ({ onSelect, onClose }) => (
          <GameOverlay title="Sala de Juegos" onClose={onClose}>
            <p className="text-sm text-gray-600">
              Elige un minijuego para que tus gatitos se diviertan y suban su felicidad.
            </p>
            <div className="grid grid-cols-1 gap-4">
              {GAME_DEFINITIONS.map((game) => (
                <button
                  key={game.id}
                  onClick={() => onSelect(game.id)}
                  className="flex items-start space-x-3 rounded-2xl border border-purple-100 bg-purple-50 hover:bg-purple-100 transition p-4 text-left"
                >
                  <span className="text-3xl" aria-hidden="true">{game.emoji}</span>
                  <div>
                    <h3 className="text-base font-semibold text-purple-700">{game.title}</h3>
                    <p className="text-sm text-gray-600">{game.description}</p>
                  </div>
                </button>
              ))}
            </div>
          </GameOverlay>
        );

        const StoreModal = ({ coins, inventory, onBuy, onUse, onReset, message }) => (
          <div className="space-y-4">
            <div className="flex items-center justify-between">
              <p className="text-sm text-gray-600">
                Usa tus monedas para mimar a los gatitos con delicias y adornos.
              </p>
              <div className="flex items-center space-x-1 text-yellow-600 font-semibold">
                <span aria-hidden="true">ü™ô</span>
                <span>{coins}</span>
              </div>
            </div>
            <div className="space-y-3">
              {STORE_ITEMS.map((item) => {
                const owned = inventory?.[item.id] || 0;
                const canAfford = coins >= item.price;
                const isConsumable = Boolean(item.effect) && item.type !== 'furniture';
                const displayAlt = item.imageAlt || item.name;
                return (
                  <div
                    key={item.id}
                    className="rounded-2xl border border-pink-100 bg-pink-50 px-4 py-3 shadow-sm"
                  >
                    <div className="flex items-start justify-between space-x-3">
                      <div>
                        <div className="flex items-center space-x-2">
                          {item.image ? (
                            <img
                              src={item.image}
                              alt={displayAlt}
                              loading="lazy"
                              className="h-10 w-10 rounded-xl object-cover shadow-sm ring-1 ring-white/70"
                            />
                          ) : (
                            <span className="text-2xl" aria-hidden="true">
                              {item.emoji}
                            </span>
                          )}
                          <h3 className="text-base font-semibold text-purple-700">{item.name}</h3>
                        </div>
                        <p className="text-sm text-gray-600 mt-1">{item.description}</p>
                        <p className="text-xs text-gray-500 mt-1">
                          Precio: <span className="font-semibold text-purple-600">{item.price}ü™ô</span>
                          {owned > 0 && (
                            <span className="ml-2 text-green-600 font-semibold">x{owned}</span>
                          )}
                        </p>
                      </div>
                      <div className="flex flex-col items-end space-y-2">
                        <button
                          onClick={() => onBuy(item)}
                          className={`px-3 py-1.5 text-xs font-semibold rounded-full transition ${
                            canAfford
                              ? 'bg-purple-500 text-white hover:bg-purple-600'
                              : 'bg-gray-200 text-gray-500 cursor-not-allowed'
                          }`}
                          disabled={!canAfford}
                        >
                          Comprar
                        </button>
                        {isConsumable && (
                          <button
                            onClick={() => onUse(item)}
                            className={`px-3 py-1.5 text-xs font-semibold rounded-full transition ${
                              owned > 0
                                ? 'bg-emerald-500 text-white hover:bg-emerald-600'
                                : 'bg-gray-200 text-gray-500 cursor-not-allowed'
                          }`}
                            disabled={owned <= 0}
                          >
                            Usar ahora
                          </button>
                        )}
                        {item.type === 'furniture' && owned > 0 && (
                          <span className="text-[11px] text-emerald-600 font-semibold">
                            Decoraci√≥n colocada
                          </span>
                        )}
                      </div>
                    </div>
                  </div>
                );
              })}
            </div>
            {message && (
              <div className="rounded-2xl border border-amber-100 bg-amber-50 px-4 py-2 text-sm text-amber-700">
                {message}
              </div>
            )}
            {typeof onReset === 'function' && (
              <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-2 text-xs text-gray-500 bg-white border border-purple-100 rounded-2xl px-4 py-3">
                <span>¬øQuieres volver a empezar? Reinicia compras y decoraciones.</span>
                <button
                  onClick={onReset}
                  className="self-start sm:self-auto px-3 py-1.5 rounded-full bg-purple-100 text-purple-700 font-semibold hover:bg-purple-200 transition"
                >
                  Reiniciar tienda
                </button>
              </div>
            )}
            <div className="text-xs text-gray-500">
              Consejo: juega a los minijuegos para ganar m√°s monedas y desbloquear todo.
            </div>
          </div>
        );

        const FlappyLukis = ({ onExit, onReward, onCatInteract, onMovementSound }) => {
          const GAME_WIDTH = 320;
          const GAME_HEIGHT = 420;
          const BIRD_SIZE = 46;
          const BIRD_X = 60;
          const OBSTACLE_WIDTH = 60;
          const GAP_HEIGHT = 220;
          const GRAVITY = 0.26;
          const OBSTACLE_SPEED = 1.85;
          const OBSTACLE_SPACING = 240;
          const FLAP_STRENGTH = -8.5;

          const [bird, setBird] = useState({ y: GAME_HEIGHT / 2 - BIRD_SIZE / 2, velocity: 0 });
          const [obstacles, setObstacles] = useState(() => []);
          const [score, setScore] = useState(0);
          const [isRunning, setIsRunning] = useState(false);
          const [isGameOver, setIsGameOver] = useState(false);
          const loopRef = useRef(null);
          const lastTimestampRef = useRef(null);
          const rewardGrantedRef = useRef(false);

          const createObstacle = useCallback((offset = 0) => {
            const gapRange = GAME_HEIGHT - GAP_HEIGHT - 160;
            const gapTop = Math.random() * Math.max(gapRange, 40) + 80;
            return {
              x: GAME_WIDTH + offset,
              gapTop,
              gapBottom: gapTop + GAP_HEIGHT,
              passed: false
            };
          }, []);

          const stopGame = useCallback(() => {
            setIsRunning(false);
            setIsGameOver(true);
          }, []);

          const resetGame = useCallback(() => {
            setBird({ y: GAME_HEIGHT / 2 - BIRD_SIZE / 2, velocity: 0 });
            setObstacles([createObstacle(), createObstacle(GAME_WIDTH / 2 + OBSTACLE_SPACING / 2)]);
            setScore(0);
            setIsGameOver(false);
            setIsRunning(true);
            rewardGrantedRef.current = false;
            lastTimestampRef.current = null;
          }, [createObstacle]);

          useEffect(() => {
            if (!isRunning) {
              if (loopRef.current) {
                cancelAnimationFrame(loopRef.current);
                loopRef.current = null;
              }
              lastTimestampRef.current = null;
              return;
            }

            const loop = (timestamp) => {
              if (lastTimestampRef.current == null) {
                lastTimestampRef.current = timestamp;
              }
              const deltaFrames = (timestamp - lastTimestampRef.current) / 16.67;
              lastTimestampRef.current = timestamp;

              setBird((prev) => {
                const newVelocity = prev.velocity + GRAVITY * deltaFrames;
                const newY = prev.y + newVelocity * deltaFrames;
                return { y: newY, velocity: newVelocity };
              });

              setObstacles((prevObstacles) => {
                let scoreGain = 0;
                const updated = prevObstacles
                  .map((obstacle) => {
                    const newX = obstacle.x - OBSTACLE_SPEED * deltaFrames;
                    let passed = obstacle.passed;
                    if (!passed && newX + OBSTACLE_WIDTH < BIRD_X) {
                      passed = true;
                      scoreGain += 1;
                    }
                    return { ...obstacle, x: newX, passed };
                  })
                  .filter((obstacle) => obstacle.x + OBSTACLE_WIDTH > -12);

                while (updated.length < 3) {
                  const last = updated[updated.length - 1];
                  const offset = last ? last.x + OBSTACLE_SPACING : GAME_WIDTH;
                  updated.push(createObstacle(offset));
                }

                if (scoreGain > 0) {
                  setScore((prevScore) => prevScore + scoreGain);
                }

                return updated;
              });

              loopRef.current = requestAnimationFrame(loop);
            };

            loopRef.current = requestAnimationFrame(loop);

            return () => {
              if (loopRef.current) {
                cancelAnimationFrame(loopRef.current);
                loopRef.current = null;
              }
              lastTimestampRef.current = null;
            };
          }, [isRunning, createObstacle]);

          useEffect(() => {
            if (!isRunning) return;

            const birdTop = bird.y;
            const birdBottom = bird.y + BIRD_SIZE;

            if (birdBottom >= GAME_HEIGHT || birdTop <= 0) {
              stopGame();
              return;
            }

            for (const obstacle of obstacles) {
              if (
                obstacle.x < BIRD_X + BIRD_SIZE &&
                obstacle.x + OBSTACLE_WIDTH > BIRD_X
              ) {
                if (birdTop < obstacle.gapTop || birdBottom > obstacle.gapBottom) {
                  stopGame();
                  break;
                }
              }
            }
          }, [bird, obstacles, isRunning, stopGame]);

          useEffect(() => {
            if (isGameOver && !rewardGrantedRef.current && typeof onReward === 'function') {
              rewardGrantedRef.current = true;
              onReward('flappy-lukis', score);
            }
          }, [isGameOver, onReward, score]);

          const flap = useCallback(() => {
            if (!isRunning) return;
            setBird((prev) => ({ y: prev.y, velocity: FLAP_STRENGTH }));
            if (typeof onMovementSound === 'function') {
              onMovementSound();
            }
          }, [isRunning, FLAP_STRENGTH, onMovementSound]);

          const handleCatTap = useCallback((event) => {
            if (event) {
              event.preventDefault();
              event.stopPropagation();
            }
            if (typeof onCatInteract === 'function') {
              onCatInteract();
            }
            flap();
          }, [flap, onCatInteract]);

          useEffect(() => {
            const handleKey = (event) => {
              if (event.code === 'Space') {
                event.preventDefault();
                if (isGameOver) {
                  resetGame();
                } else {
                  flap();
                }
              }
            };
            window.addEventListener('keydown', handleKey);
            return () => window.removeEventListener('keydown', handleKey);
          }, [flap, isGameOver, resetGame]);

          useEffect(() => () => {
            if (loopRef.current) {
              cancelAnimationFrame(loopRef.current);
            }
          }, []);

          return (
            <div className="space-y-4">
              <div className="flex items-center justify-between text-sm text-gray-600">
                <span>Puntuaci√≥n: <span className="font-semibold text-purple-600">{score}</span></span>
                <button
                  onClick={onExit}
                  className="px-3 py-1.5 text-xs font-semibold rounded-full bg-gray-200 hover:bg-gray-300 transition"
                >
                  Salir
                </button>
              </div>
              <div
                className="relative mx-auto rounded-3xl overflow-hidden shadow-inner"
                style={{ width: GAME_WIDTH, height: GAME_HEIGHT }}
              >
                <div
                  className="absolute inset-0 bg-gradient-to-b from-sky-200 via-sky-100 to-emerald-100"
                  onClick={flap}
                  onTouchStart={(event) => {
                    event.preventDefault();
                    flap();
                  }}
                >
                  {(() => {
                    const tilt = Math.max(Math.min(bird.velocity * 2.6, 32), -32);
                    return (
                      <div
                        className="absolute flex items-center justify-center"
                        style={{
                          left: `${BIRD_X}px`,
                          top: `${bird.y}px`,
                          width: `${BIRD_SIZE}px`,
                          height: `${BIRD_SIZE}px`,
                          transform: `rotate(${tilt}deg)`
                        }}
                        onClick={handleCatTap}
                        onTouchStart={handleCatTap}
                      >
                        <CatAvatar
                          type="tuxedo"
                          eyeColorClass="bg-amber-300"
                          name="Lukis"
                          size={BIRD_SIZE}
                          className="drop-shadow-lg"
                        />
                      </div>
                    );
                  })()}
                  {obstacles.map((obstacle, index) => (
                    <React.Fragment key={index}>
                      <div
                        className="absolute bg-emerald-500 border-2 border-emerald-300 rounded-b-2xl"
                        style={{
                          left: `${obstacle.x}px`,
                          top: 0,
                          width: `${OBSTACLE_WIDTH}px`,
                          height: `${obstacle.gapTop}px`
                        }}
                      />
                      <div
                        className="absolute bg-emerald-500 border-2 border-emerald-300 rounded-t-2xl"
                        style={{
                          left: `${obstacle.x}px`,
                          top: `${obstacle.gapBottom}px`,
                          width: `${OBSTACLE_WIDTH}px`,
                          height: `${GAME_HEIGHT - obstacle.gapBottom}px`
                        }}
                      />
                    </React.Fragment>
                  ))}
                  {!isRunning && !isGameOver && (
                    <div className="absolute inset-0 flex flex-col items-center justify-center bg-white/70 text-center p-6 space-y-2">
                      <span className="text-4xl">üêæ</span>
                      <p className="text-base font-semibold text-purple-600">Pulsa para comenzar</p>
                      <p className="text-sm text-gray-600">Toca o presiona la barra espaciadora para que Lukis aletee.</p>
                      <button
                        onClick={resetGame}
                        className="mt-2 px-4 py-2 rounded-full bg-purple-500 text-white text-sm font-semibold hover:bg-purple-600 transition"
                      >
                        ¬°Empezar!
                      </button>
                    </div>
                  )}
                  {isGameOver && (
                    <div className="absolute inset-0 flex flex-col items-center justify-center bg-white/70 text-center p-6 space-y-2">
                      <span className="text-4xl">üí•</span>
                      <p className="text-base font-semibold text-purple-600">¬°Ups! Lukis se ha cansado.</p>
                      <p className="text-sm text-gray-600">Puntuaci√≥n final: {score}</p>
                      <div className="flex space-x-2">
                        <button
                          onClick={resetGame}
                          className="px-4 py-2 rounded-full bg-purple-500 text-white text-sm font-semibold hover:bg-purple-600 transition"
                        >
                          Intentar de nuevo
                        </button>
                        <button
                          onClick={onExit}
                          className="px-4 py-2 rounded-full bg-gray-200 text-sm font-semibold hover:bg-gray-300 transition"
                        >
                          Salir
                        </button>
                      </div>
                    </div>
                  )}
                </div>
              </div>
            </div>
          );
        };

        const LukisSkyJump = ({ onExit, onReward, onCatInteract, onMovementSound }) => {
          const GAME_WIDTH = 320;
          const GAME_HEIGHT = 430;
          const PLAYER_SIZE = 44;
          const GRAVITY = 0.55;
          const JUMP_FORCE = 11.5;
          const MOVE_SPEED = 4.2;

          const createInitialPlatforms = useCallback(() => {
            const basePlatforms = [];
            const step = GAME_HEIGHT / 6.5;
            for (let i = 0; i < 6; i += 1) {
              const width = Math.random() * 45 + 80;
              const x = Math.random() * (GAME_WIDTH - width);
              const y = GAME_HEIGHT - i * step - 52;
              basePlatforms.push({ x, y, width });
            }
            basePlatforms.push({
              x: GAME_WIDTH / 2 - 60,
              y: GAME_HEIGHT - 20,
              width: 120
            });
            return basePlatforms;
          }, []);

          const getInitialPlayer = useCallback(
            () => ({ x: GAME_WIDTH / 2 - PLAYER_SIZE / 2, y: GAME_HEIGHT - 140, vy: 0 }),
            []
          );

          const [player, setPlayer] = useState(() => getInitialPlayer());
          const [platforms, setPlatforms] = useState(() => createInitialPlatforms());
          const [score, setScore] = useState(0);
          const [isRunning, setIsRunning] = useState(false);
          const [isGameOver, setIsGameOver] = useState(false);
          const [activeDirection, setActiveDirection] = useState(null);

          const playerRef = useRef(player);
          const platformsRef = useRef(platforms);
          const scoreRef = useRef(score);
          const inputsRef = useRef({ left: false, right: false });
          const totalHeightRef = useRef(0);
          const rewardGrantedRef = useRef(false);

          useEffect(() => {
            playerRef.current = player;
          }, [player]);

          useEffect(() => {
            platformsRef.current = platforms;
          }, [platforms]);

          useEffect(() => {
            scoreRef.current = score;
          }, [score]);

          const resetGame = useCallback(() => {
            const initialPlatforms = createInitialPlatforms();
            const initialPlayer = getInitialPlayer();
            totalHeightRef.current = 0;
            scoreRef.current = 0;
            inputsRef.current.left = false;
            inputsRef.current.right = false;
            setActiveDirection(null);
            setScore(0);
            setPlatforms(initialPlatforms);
            setPlayer(initialPlayer);
            platformsRef.current = initialPlatforms;
            playerRef.current = initialPlayer;
            setIsGameOver(false);
            setIsRunning(true);
            rewardGrantedRef.current = false;
          }, [createInitialPlatforms, getInitialPlayer]);

          useEffect(() => {
            if (!isRunning) {
              inputsRef.current.left = false;
              inputsRef.current.right = false;
              setActiveDirection(null);
            }
          }, [isRunning]);

          const handleControlStart = useCallback((direction) => {
            inputsRef.current[direction] = true;
            setActiveDirection(direction);
            if (typeof onMovementSound === 'function') {
              onMovementSound();
            }
          }, [onMovementSound]);

          const handleControlEnd = useCallback((direction) => {
            inputsRef.current[direction] = false;
            setActiveDirection((prev) => (prev === direction ? null : prev));
          }, []);

          useEffect(() => {
            const handleKeyDown = (event) => {
              if (event.code === 'ArrowLeft' || event.code === 'KeyA') {
                if (!inputsRef.current.left) {
                  inputsRef.current.left = true;
                  setActiveDirection('left');
                  if (typeof onMovementSound === 'function') {
                    onMovementSound();
                  }
                }
              } else if (event.code === 'ArrowRight' || event.code === 'KeyD') {
                if (!inputsRef.current.right) {
                  inputsRef.current.right = true;
                  setActiveDirection('right');
                  if (typeof onMovementSound === 'function') {
                    onMovementSound();
                  }
                }
              } else if (event.code === 'Space') {
                if (!isRunning) {
                  event.preventDefault();
                  resetGame();
                }
              }
            };

            const handleKeyUp = (event) => {
              if (event.code === 'ArrowLeft' || event.code === 'KeyA') {
                inputsRef.current.left = false;
                setActiveDirection((prev) => (prev === 'left' ? null : prev));
              } else if (event.code === 'ArrowRight' || event.code === 'KeyD') {
                inputsRef.current.right = false;
                setActiveDirection((prev) => (prev === 'right' ? null : prev));
              }
            };

            window.addEventListener('keydown', handleKeyDown);
            window.addEventListener('keyup', handleKeyUp);
            return () => {
              window.removeEventListener('keydown', handleKeyDown);
              window.removeEventListener('keyup', handleKeyUp);
            };
          }, [isRunning, onMovementSound, resetGame]);

          const updateGame = useCallback(() => {
            const currentPlayer = playerRef.current;
            const currentPlatforms = platformsRef.current;
            let newVelocity = currentPlayer.vy + GRAVITY;
            let newX = currentPlayer.x;
            let jumped = false;

            if (inputsRef.current.left) {
              newX -= MOVE_SPEED;
            }
            if (inputsRef.current.right) {
              newX += MOVE_SPEED;
            }

            if (newX < -PLAYER_SIZE / 2) {
              newX = GAME_WIDTH - PLAYER_SIZE / 2;
            } else if (newX > GAME_WIDTH - PLAYER_SIZE / 2) {
              newX = -PLAYER_SIZE / 2;
            }

            let newY = currentPlayer.y + newVelocity;
            const prevBottom = currentPlayer.y + PLAYER_SIZE;
            const nextBottom = newY + PLAYER_SIZE;

            for (const platform of currentPlatforms) {
              if (
                prevBottom <= platform.y &&
                nextBottom >= platform.y &&
                newX + PLAYER_SIZE > platform.x &&
                newX < platform.x + platform.width &&
                newVelocity > 0
              ) {
                newVelocity = -JUMP_FORCE;
                newY = platform.y - PLAYER_SIZE;
                jumped = true;
                break;
              }
            }

            if (jumped && typeof onMovementSound === 'function') {
              onMovementSound();
            }

            let verticalShift = 0;
            const scrollThreshold = GAME_HEIGHT * 0.4;
            if (newY < scrollThreshold) {
              verticalShift = scrollThreshold - newY;
              newY = scrollThreshold;
            }

            let updatedPlatforms = currentPlatforms
              .map((platform) => ({ ...platform, y: platform.y + verticalShift }))
              .filter((platform) => platform.y < GAME_HEIGHT + 40);

            while (updatedPlatforms.length < 8) {
              const highestY = updatedPlatforms.reduce(
                (min, platform) => Math.min(min, platform.y),
                GAME_HEIGHT
              );
              const platformY = (Number.isFinite(highestY) ? highestY : GAME_HEIGHT) - (Math.random() * 55 + 55);
              const width = Math.random() * 45 + 80;
              updatedPlatforms.push({
                x: Math.random() * (GAME_WIDTH - width),
                y: platformY,
                width
              });
            }

            if (verticalShift > 0) {
              totalHeightRef.current += verticalShift;
              const computedScore = Math.max(
                scoreRef.current,
                Math.floor(totalHeightRef.current / 45)
              );
              if (computedScore !== scoreRef.current) {
                scoreRef.current = computedScore;
                setScore(computedScore);
              }
            }

            if (newY > GAME_HEIGHT) {
              setIsRunning(false);
              setIsGameOver(true);
              inputsRef.current.left = false;
              inputsRef.current.right = false;
              return;
            }

            const nextPlayer = { x: newX, y: newY, vy: newVelocity };
            playerRef.current = nextPlayer;
            platformsRef.current = updatedPlatforms;

            setPlayer(nextPlayer);
            setPlatforms(updatedPlatforms);
          }, [onMovementSound]);

          useEffect(() => {
            if (!isRunning) return;
            const interval = setInterval(updateGame, 30);
            return () => clearInterval(interval);
          }, [isRunning, updateGame]);

          useEffect(() => {
            if (isGameOver && !rewardGrantedRef.current && typeof onReward === 'function') {
              rewardGrantedRef.current = true;
              onReward('lukis-sky-jump', score);
            }
          }, [isGameOver, onReward, score]);

          const tilt = Math.max(Math.min(player.vy * 1.8, 24), -24);

          const handleCatTap = useCallback((event) => {
            if (event) {
              event.preventDefault();
              event.stopPropagation();
            }
            if (typeof onCatInteract === 'function') {
              onCatInteract();
            }
          }, [onCatInteract]);

          return (
            <div className="space-y-3">
              <div className="flex items-center justify-between text-sm text-gray-600">
                <span>Altura: <span className="font-semibold text-purple-600">{score}</span></span>
                <button
                  onClick={onExit}
                  className="px-3 py-1.5 text-xs font-semibold rounded-full bg-gray-200 hover:bg-gray-300 transition"
                >
                  Salir
                </button>
              </div>
              <div
                className="relative mx-auto rounded-3xl overflow-hidden shadow-inner"
                style={{ width: GAME_WIDTH, height: GAME_HEIGHT }}
              >
                <div className="absolute inset-0 bg-gradient-to-b from-sky-200 via-slate-100 to-white">
                  {platforms.map((platform, index) => (
                    <div
                      key={index}
                      className="absolute bg-emerald-200 border border-emerald-400 rounded-2xl shadow-sm"
                      style={{
                        left: `${platform.x}px`,
                        top: `${platform.y}px`,
                        width: `${platform.width}px`,
                        height: '14px'
                      }}
                    ></div>
                  ))}
                  <div
                    className="absolute flex items-center justify-center transition-transform duration-75"
                    style={{
                      left: `${player.x}px`,
                      top: `${player.y}px`,
                      width: `${PLAYER_SIZE}px`,
                      height: `${PLAYER_SIZE}px`,
                      transform: `rotate(${tilt}deg)`
                    }}
                    onClick={handleCatTap}
                    onTouchStart={handleCatTap}
                  >
                    <CatAvatar
                      type="tuxedo"
                      eyeColorClass="bg-amber-300"
                      name="Lukis"
                      size={PLAYER_SIZE}
                      className="drop-shadow-lg"
                    />
                  </div>
                  {!isRunning && !isGameOver && (
                    <div className="absolute inset-0 flex flex-col items-center justify-center bg-white/75 text-center p-6 space-y-3">
                      <span className="text-4xl">‚òÅÔ∏è</span>
                      <p className="text-base font-semibold text-purple-600">¬°Hora de saltar!</p>
                      <p className="text-sm text-gray-600">Usa las flechas, las teclas A/D o los botones para moverte.</p>
                      <button
                        onClick={resetGame}
                        className="px-4 py-2 rounded-full bg-purple-500 text-white text-sm font-semibold hover:bg-purple-600 transition"
                      >
                        ¬°A las nubes!
                      </button>
                    </div>
                  )}
                  {isGameOver && (
                    <div className="absolute inset-0 flex flex-col items-center justify-center bg-white/80 text-center p-6 space-y-3">
                      <span className="text-4xl">üåßÔ∏è</span>
                      <p className="text-base font-semibold text-purple-600">¬°Buen intento!</p>
                      <p className="text-sm text-gray-600">Altura alcanzada: {score}</p>
                      <div className="flex space-x-2">
                        <button
                          onClick={resetGame}
                          className="px-4 py-2 rounded-full bg-purple-500 text-white text-sm font-semibold hover:bg-purple-600 transition"
                        >
                          Intentar de nuevo
                        </button>
                        <button
                          onClick={onExit}
                          className="px-4 py-2 rounded-full bg-gray-200 text-sm font-semibold hover:bg-gray-300 transition"
                        >
                          Salir
                        </button>
                      </div>
                    </div>
                  )}
                </div>
              </div>
              <div className="flex flex-wrap items-center justify-center gap-3 w-full">
                <button
                  type="button"
                  onMouseDown={() => handleControlStart('left')}
                  onMouseUp={() => handleControlEnd('left')}
                  onMouseLeave={() => handleControlEnd('left')}
                  onTouchStart={(event) => {
                    event.preventDefault();
                    handleControlStart('left');
                  }}
                  onTouchEnd={() => handleControlEnd('left')}
                  onTouchCancel={() => handleControlEnd('left')}
                  className={`px-5 py-3 text-lg font-semibold rounded-full border transition shadow ${
                    activeDirection === 'left'
                      ? 'bg-purple-500 text-white border-purple-500'
                      : 'bg-white text-purple-600 border-purple-200 hover:border-purple-400'
                  }`}
                >
                  ‚óÄÔ∏é
                </button>
                <button
                  type="button"
                  onMouseDown={() => handleControlStart('right')}
                  onMouseUp={() => handleControlEnd('right')}
                  onMouseLeave={() => handleControlEnd('right')}
                  onTouchStart={(event) => {
                    event.preventDefault();
                    handleControlStart('right');
                  }}
                  onTouchEnd={() => handleControlEnd('right')}
                  onTouchCancel={() => handleControlEnd('right')}
                  className={`px-5 py-3 text-lg font-semibold rounded-full border transition shadow ${
                    activeDirection === 'right'
                      ? 'bg-purple-500 text-white border-purple-500'
                      : 'bg-white text-purple-600 border-purple-200 hover:border-purple-400'
                  }`}
                >
                  ‚ñ∂Ô∏é
                </button>
              </div>
            </div>
          );
        };



        const LukisTreatDash = ({ onExit, onReward, onCatInteract, onMovementSound }) => {
          const GAME_WIDTH = 320;
          const GAME_HEIGHT = 430;
          const PLAYER_SIZE = 52;
          const ITEM_SIZE = 34;
          const HAZARD_SIZE = 40;
          const MOVE_SPEED = 5.5;
          const MAX_MISSES = 5;
          const FLOOR_Y = GAME_HEIGHT - PLAYER_SIZE - 18;

          const createInitialPlayer = useCallback(
            () => ({ x: GAME_WIDTH / 2 - PLAYER_SIZE / 2, y: FLOOR_Y }),
            []
          );

          const [player, setPlayer] = useState(() => createInitialPlayer());
          const [items, setItems] = useState([]);
          const [hazards, setHazards] = useState([]);
          const [score, setScore] = useState(0);
          const [misses, setMisses] = useState(0);
          const [lives, setLives] = useState(3);
          const [isRunning, setIsRunning] = useState(false);
          const [isGameOver, setIsGameOver] = useState(false);
          const [activeDirection, setActiveDirection] = useState(null);
          const stageContainerRef = useRef(null);
          const [stageScale, setStageScale] = useState(1);

          const loopRef = useRef(null);
          const lastTimestampRef = useRef(null);
          const spawnAccumulatorRef = useRef(0);
          const hazardAccumulatorRef = useRef(0);
          const inputsRef = useRef({ left: false, right: false });
          const playerRef = useRef(player);
          const itemsRef = useRef(items);
          const hazardsRef = useRef(hazards);
          const scoreRef = useRef(score);
          const missesRef = useRef(misses);
          const livesRef = useRef(lives);
          const rewardGrantedRef = useRef(false);

          useEffect(() => {
            playerRef.current = player;
          }, [player]);

          useEffect(() => {
            itemsRef.current = items;
          }, [items]);

          useEffect(() => {
            hazardsRef.current = hazards;
          }, [hazards]);

          useEffect(() => {
            scoreRef.current = score;
          }, [score]);

          useEffect(() => {
            missesRef.current = misses;
          }, [misses]);

          useEffect(() => {
            livesRef.current = lives;
          }, [lives]);

          useEffect(() => {
            const updateScale = () => {
              if (!stageContainerRef.current) {
                return;
              }
              const availableWidth = stageContainerRef.current.offsetWidth;
              if (!availableWidth) {
                setStageScale(1);
                return;
              }
              const nextScale = Math.min(1, availableWidth / GAME_WIDTH);
              setStageScale(nextScale);
            };

            updateScale();

            if (typeof ResizeObserver !== 'undefined') {
              const observer = new ResizeObserver(updateScale);
              const container = stageContainerRef.current;
              if (container) {
                observer.observe(container);
              }
              return () => observer.disconnect();
            }

            window.addEventListener('resize', updateScale);
            return () => window.removeEventListener('resize', updateScale);
          }, []);

          const clampValue = useCallback((value, min, max) => Math.min(Math.max(value, min), max), []);

          const prepareGame = useCallback(() => {
            const initialPlayer = createInitialPlayer();
            playerRef.current = initialPlayer;
            itemsRef.current = [];
            hazardsRef.current = [];
            scoreRef.current = 0;
            missesRef.current = 0;
            livesRef.current = 3;
            spawnAccumulatorRef.current = 0;
            hazardAccumulatorRef.current = 0;
            lastTimestampRef.current = null;
            rewardGrantedRef.current = false;
            setPlayer(initialPlayer);
            setItems([]);
            setHazards([]);
            setScore(0);
            setMisses(0);
            setLives(3);
          }, [createInitialPlayer]);

          const startGame = useCallback(() => {
            prepareGame();
            setIsGameOver(false);
            setIsRunning(true);
          }, [prepareGame]);

          const stopGame = useCallback(() => {
            setIsRunning(false);
            setIsGameOver(true);
            lastTimestampRef.current = null;
          }, []);

          const handleControlStart = useCallback((direction) => {
            inputsRef.current[direction] = true;
            setActiveDirection(direction);
            if (typeof onMovementSound === 'function') {
              onMovementSound();
            }
          }, [onMovementSound]);

          const handleControlEnd = useCallback((direction) => {
            inputsRef.current[direction] = false;
            setActiveDirection((prev) => (prev === direction ? null : prev));
          }, []);

          const checkCollision = (ax, ay, aw, ah, bx, by, bw, bh) =>
            ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;

          useEffect(() => {
            if (!isRunning) {
              if (loopRef.current) {
                cancelAnimationFrame(loopRef.current);
                loopRef.current = null;
              }
              lastTimestampRef.current = null;
              return;
            }

            const loop = (timestamp) => {
              if (lastTimestampRef.current == null) {
                lastTimestampRef.current = timestamp;
              }
              const delta = Math.min(3, (timestamp - lastTimestampRef.current) / 16.67);
              lastTimestampRef.current = timestamp;

              const direction = (inputsRef.current.right ? 1 : 0) - (inputsRef.current.left ? 1 : 0);
              if (direction !== 0) {
                const boost = 1 + Math.min(20, scoreRef.current) * 0.015;
                const nextX = clampValue(
                  playerRef.current.x + direction * MOVE_SPEED * boost * delta,
                  0,
                  GAME_WIDTH - PLAYER_SIZE
                );
                if (nextX !== playerRef.current.x) {
                  const updatedPlayer = { ...playerRef.current, x: nextX };
                  playerRef.current = updatedPlayer;
                  setPlayer(updatedPlayer);
                }
              }

              spawnAccumulatorRef.current += delta;
              hazardAccumulatorRef.current += delta;

              const spawnThreshold = Math.max(14, 28 - Math.floor(scoreRef.current / 1.8));
              if (spawnAccumulatorRef.current >= spawnThreshold) {
                spawnAccumulatorRef.current = 0;
                const treat = {
                  id: `${Date.now()}-${Math.random()}`,
                  x: Math.random() * (GAME_WIDTH - ITEM_SIZE),
                  y: -ITEM_SIZE,
                  speed: 2.3 + Math.random() * 1.2
                };
                const nextItems = [...itemsRef.current, treat];
                itemsRef.current = nextItems;
                setItems(nextItems);
              }

              if (scoreRef.current > 4) {
                const hazardThreshold = Math.max(32, 64 - scoreRef.current * 2);
                if (hazardAccumulatorRef.current >= hazardThreshold) {
                  hazardAccumulatorRef.current = 0;
                  const hazard = {
                    id: `${Date.now()}-hazard-${Math.random()}`,
                    x: Math.random() * (GAME_WIDTH - HAZARD_SIZE),
                    y: -HAZARD_SIZE,
                    speed: 2.1 + Math.random() * 1.3
                  };
                  const nextHazards = [...hazardsRef.current, hazard];
                  hazardsRef.current = nextHazards;
                  setHazards(nextHazards);
                }
              }

              let newScore = scoreRef.current;
              let newMisses = missesRef.current;
              let livesLost = 0;

              const playerBox = {
                x: playerRef.current.x,
                y: FLOOR_Y,
                w: PLAYER_SIZE,
                h: PLAYER_SIZE
              };

              const updatedItems = [];
              itemsRef.current.forEach((item) => {
                const fallSpeed = (item.speed + Math.min(scoreRef.current * 0.05, 1.8)) * delta * 2.2;
                const nextY = item.y + fallSpeed;
                if (checkCollision(playerBox.x, playerBox.y, playerBox.w, playerBox.h, item.x, nextY, ITEM_SIZE, ITEM_SIZE)) {
                  newScore += 1;
                  return;
                }
                if (nextY > GAME_HEIGHT) {
                  newMisses += 1;
                  return;
                }
                updatedItems.push({ ...item, y: nextY });
              });
              itemsRef.current = updatedItems;
              setItems(updatedItems);

              const updatedHazards = [];
              hazardsRef.current.forEach((hazard) => {
                const fallSpeed = (hazard.speed + Math.min(scoreRef.current * 0.05, 1.6)) * delta * 2.4;
                const nextY = hazard.y + fallSpeed;
                if (
                  checkCollision(
                    playerBox.x + 6,
                    playerBox.y + 6,
                    playerBox.w - 12,
                    playerBox.h - 12,
                    hazard.x,
                    nextY,
                    HAZARD_SIZE,
                    HAZARD_SIZE
                  )
                ) {
                  livesLost += 1;
                  return;
                }
                if (nextY > GAME_HEIGHT) {
                  return;
                }
                updatedHazards.push({ ...hazard, y: nextY });
              });
              hazardsRef.current = updatedHazards;
              setHazards(updatedHazards);

              if (newScore !== scoreRef.current) {
                scoreRef.current = newScore;
                setScore(newScore);
              }

              if (newMisses !== missesRef.current) {
                missesRef.current = newMisses;
                setMisses(newMisses);
              }

              if (livesLost > 0) {
                const remainingLives = Math.max(0, livesRef.current - livesLost);
                livesRef.current = remainingLives;
                setLives(remainingLives);
                if (remainingLives <= 0) {
                  stopGame();
                  return;
                }
              }

              if (missesRef.current >= MAX_MISSES) {
                stopGame();
                return;
              }

              loopRef.current = requestAnimationFrame(loop);
            };

            loopRef.current = requestAnimationFrame(loop);

            return () => {
              if (loopRef.current) {
                cancelAnimationFrame(loopRef.current);
                loopRef.current = null;
              }
              lastTimestampRef.current = null;
            };
          }, [isRunning, clampValue, stopGame]);

          useEffect(() => {
            if (isGameOver && !rewardGrantedRef.current && typeof onReward === 'function') {
              rewardGrantedRef.current = true;
              onReward('lukis-treat-dash', score);
            }
          }, [isGameOver, onReward, score]);

          useEffect(() => {
            const handleKeyDown = (event) => {
              if (event.code === 'ArrowLeft' || event.code === 'KeyA') {
                if (!inputsRef.current.left) {
                  event.preventDefault();
                  inputsRef.current.left = true;
                  setActiveDirection('left');
                  if (typeof onMovementSound === 'function') {
                    onMovementSound();
                  }
                }
              } else if (event.code === 'ArrowRight' || event.code === 'KeyD') {
                if (!inputsRef.current.right) {
                  event.preventDefault();
                  inputsRef.current.right = true;
                  setActiveDirection('right');
                  if (typeof onMovementSound === 'function') {
                    onMovementSound();
                  }
                }
              } else if (event.code === 'Space') {
                if (!isRunning) {
                  event.preventDefault();
                  startGame();
                }
              }
            };

            const handleKeyUp = (event) => {
              if (event.code === 'ArrowLeft' || event.code === 'KeyA') {
                inputsRef.current.left = false;
                setActiveDirection((prev) => (prev === 'left' ? null : prev));
              } else if (event.code === 'ArrowRight' || event.code === 'KeyD') {
                inputsRef.current.right = false;
                setActiveDirection((prev) => (prev === 'right' ? null : prev));
              }
            };

            window.addEventListener('keydown', handleKeyDown);
            window.addEventListener('keyup', handleKeyUp);
            return () => {
              window.removeEventListener('keydown', handleKeyDown);
              window.removeEventListener('keyup', handleKeyUp);
            };
          }, [isRunning, onMovementSound, startGame]);

          const scoreLabel = score.toString().padStart(2, '0');
          const missesLeft = Math.max(0, MAX_MISSES - misses);
          const safeScale = Number.isFinite(stageScale) && stageScale > 0 ? stageScale : 1;
          const scaledWidth = GAME_WIDTH * safeScale;
          const scaledHeight = GAME_HEIGHT * safeScale;
          const scaledItemSize = ITEM_SIZE * safeScale;
          const scaledHazardSize = HAZARD_SIZE * safeScale;
          const scaledPlayerSize = PLAYER_SIZE * safeScale;

          const handleCatTap = useCallback((event) => {
            if (event) {
              event.preventDefault();
              event.stopPropagation();
            }
            if (typeof onCatInteract === 'function') {
              onCatInteract();
            }
          }, [onCatInteract]);

          return (
            <div className="space-y-4">
              <div className="rounded-3xl bg-gradient-to-br from-amber-50 via-white to-purple-50 p-5 shadow-lg border border-purple-200">
                <div className="flex flex-wrap items-center justify-between gap-3 text-sm text-gray-600">
                  <div className="flex flex-wrap items-center gap-3">
                    <span>Puntos: <span className="font-semibold text-purple-600">{scoreLabel}</span></span>
                    <span>Vidas: <span className="font-semibold text-purple-600">{lives}</span></span>
                    <span>Fallos: <span className="font-semibold text-purple-600">{misses}/{MAX_MISSES}</span></span>
                  </div>
                  <button
                    onClick={onExit}
                    className="px-3 py-1.5 text-xs font-semibold rounded-full bg-gray-200 hover:bg-gray-300 transition"
                  >
                    Salir
                  </button>
                </div>
                <div ref={stageContainerRef} className="mt-4">
                  <div
                    className="relative mx-auto overflow-hidden rounded-3xl border-4 border-purple-200 bg-gradient-to-b from-sky-100 via-amber-50 to-rose-100 shadow-inner"
                    style={{ width: `${scaledWidth}px`, height: `${scaledHeight}px` }}
                  >
                    <div
                      className="absolute inset-0 pointer-events-none"
                      style={{ backgroundImage: 'linear-gradient(to top, rgba(255, 236, 209, 0.45) 12%, transparent 48%)' }}
                    />
                    <div
                      className="absolute inset-x-0 bottom-0 bg-gradient-to-t from-amber-200 via-amber-100/90 to-transparent"
                      style={{ height: `${64 * safeScale}px` }}
                    />
                    {items.map((item) => (
                      <div
                        key={item.id}
                        className="absolute flex items-center justify-center text-3xl drop-shadow-sm"
                        style={{
                          left: `${item.x * safeScale}px`,
                          top: `${item.y * safeScale}px`,
                          width: `${scaledItemSize}px`,
                          height: `${scaledItemSize}px`,
                          fontSize: `${Math.max(18, 28 * safeScale)}px`
                        }}
                      >
                        üêü
                      </div>
                    ))}
                    {hazards.map((hazard) => (
                      <div
                        key={hazard.id}
                        className="absolute flex items-center justify-center text-3xl drop-shadow-sm"
                        style={{
                          left: `${hazard.x * safeScale}px`,
                          top: `${hazard.y * safeScale}px`,
                          width: `${scaledHazardSize}px`,
                          height: `${scaledHazardSize}px`,
                          fontSize: `${Math.max(18, 28 * safeScale)}px`
                        }}
                      >
                        üß∂
                      </div>
                    ))}
                    <div
                      className="absolute flex items-center justify-center transition-transform duration-75"
                      style={{
                        left: `${player.x * safeScale}px`,
                        top: `${player.y * safeScale}px`,
                        width: `${scaledPlayerSize}px`,
                        height: `${scaledPlayerSize}px`
                      }}
                      onClick={handleCatTap}
                      onTouchStart={handleCatTap}
                    >
                      <div className="relative h-full w-full">
                        <CatAvatar
                          type="tuxedo"
                          eyeColorClass="bg-amber-300"
                          name="Lukis"
                          size={scaledPlayerSize}
                          className="drop-shadow-lg"
                        />
                      </div>
                    </div>
                    {!isRunning && !isGameOver && (
                      <div className="absolute inset-0 flex flex-col items-center justify-center bg-white/80 text-center p-6 space-y-3">
                        <span className="text-4xl">üç§</span>
                        <p className="text-base font-semibold text-purple-600">¬°Hora de cazar premios!</p>
                        <p className="text-sm text-gray-600">Usa las flechas, las teclas A/D o los botones para deslizarte. Pulsa espacio para empezar.</p>
                        <button
                          onClick={startGame}
                          className="px-4 py-2 rounded-full bg-purple-500 text-white text-sm font-semibold hover:bg-purple-600 transition"
                        >
                          ¬°Comenzar!
                        </button>
                      </div>
                    )}
                    {isGameOver && (
                      <div className="absolute inset-0 flex flex-col items-center justify-center bg-white/85 text-center p-6 space-y-3">
                        <span className="text-4xl">üéâ</span>
                        <p className="text-base font-semibold text-purple-600">¬°Buen trabajo, cazador!</p>
                        <p className="text-sm text-gray-600">Premios atrapados: {score}. Golosinas perdidas restantes: {missesLeft === 0 ? 'ninguna' : missesLeft}</p>
                        <div className="flex space-x-2">
                          <button
                            onClick={startGame}
                            className="px-4 py-2 rounded-full bg-purple-500 text-white text-sm font-semibold hover:bg-purple-600 transition"
                          >
                            Intentar de nuevo
                          </button>
                          <button
                            onClick={onExit}
                            className="px-4 py-2 rounded-full bg-gray-200 text-sm font-semibold hover:bg-gray-300 transition"
                          >
                            Salir
                          </button>
                        </div>
                      </div>
                    )}
                  </div>
                </div>
              </div>
              <div className="flex flex-wrap items-center justify-center gap-3 w-full -mt-2">
                <button
                  type="button"
                  onMouseDown={() => handleControlStart('left')}
                  onMouseUp={() => handleControlEnd('left')}
                  onMouseLeave={() => handleControlEnd('left')}
                  onTouchStart={(event) => {
                    event.preventDefault();
                    handleControlStart('left');
                  }}
                  onTouchEnd={() => handleControlEnd('left')}
                  onTouchCancel={() => handleControlEnd('left')}
                  className={`px-5 py-3 text-lg font-semibold rounded-full border transition shadow ${
                    activeDirection === 'left'
                      ? 'bg-purple-500 text-white border-purple-500'
                      : 'bg-white text-purple-600 border-purple-200 hover:border-purple-400'
                  }`}
                >
                  ‚óÄÔ∏é
                </button>
                <button
                  type="button"
                  onMouseDown={() => handleControlStart('right')}
                  onMouseUp={() => handleControlEnd('right')}
                  onMouseLeave={() => handleControlEnd('right')}
                  onTouchStart={(event) => {
                    event.preventDefault();
                    handleControlStart('right');
                  }}
                  onTouchEnd={() => handleControlEnd('right')}
                  onTouchCancel={() => handleControlEnd('right')}
                  className={`px-5 py-3 text-lg font-semibold rounded-full border transition shadow ${
                    activeDirection === 'right'
                      ? 'bg-purple-500 text-white border-purple-500'
                      : 'bg-white text-purple-600 border-purple-200 hover:border-purple-400'
                  }`}
                >
                  ‚ñ∂Ô∏é
                </button>
              </div>
            </div>
          );
        };
        const SOUND_LIBRARY = {
          meow: {
            files: ['meow-1.mp3', 'meow_QO6VsE6.mp3', 'the-end-meow-by-nekocat-just-3-second-1.mp3'],
            volume: 0.6
          },
          purr: {
            files: ['cat-purr.mp3', 'little-puff-purr.mp3', 'little-puff-purr-brr.mp3'],
            volume: 0.45
          },
          gameMove: {
            files: ['sound1.wav'],
            volume: 0.28
          }
        };

        const ACTION_SOUNDS = {
          feed: ['meow', 'purr'],
          play: ['meow'],
          sleep: ['purr']
        };

        const REMINDER_DELAY_MS = 1000 * 60 * 90;
        const REMINDER_MIN_DELAY_MS = 1000 * 30;
        const REMINDER_SYNC_TAG = 'catagotchi-reminder';

        const sendMessageToServiceWorker = async (message) => {
          if (typeof navigator === 'undefined' || !navigator.serviceWorker) {
            return;
          }
          try {
            const registration = await navigator.serviceWorker.ready;
            const targets = [
              navigator.serviceWorker.controller,
              registration?.active,
              registration?.waiting,
              registration?.installing
            ].filter(Boolean);
            targets.forEach((worker) => {
              try {
                worker.postMessage(message);
              } catch (error) {
                console.warn('No se pudo enviar el mensaje al service worker', error);
              }
            });
          } catch (error) {
            console.warn('No se pudo comunicar con el service worker', error);
          }
        };

        const clamp = (value, min, max) => Math.min(Math.max(value, min), max);

        const createSoundController = () => {
          if (typeof Audio === 'undefined') {
            return null;
          }

          const pools = Object.entries(SOUND_LIBRARY).reduce((acc, [key, definition]) => {
            const { files = [], volume = 0.5 } = definition || {};
            const entries = files.filter(Boolean).map(src => {
              const element = new Audio(src);
              element.preload = 'auto';
              element.volume = volume;
              return { src, instances: [element], volume };
            });
            if (entries.length > 0) {
              acc[key] = entries;
            }
            return acc;
          }, {});

          const getInstance = (entry) => {
            if (!entry) return null;
            const available = entry.instances.find(audio => audio.paused);
            if (available) {
              return available;
            }
            const clone = entry.instances[0]?.cloneNode(true) || new Audio(entry.src);
            clone.volume = entry.volume;
            clone.preload = 'auto';
            entry.instances.push(clone);
            return clone;
          };

          const playEffect = (effectKey) => {
            const entries = pools[effectKey];
            if (!entries || entries.length === 0) return;
            const entry = entries[Math.floor(Math.random() * entries.length)];
            const audio = getInstance(entry);
            if (!audio) return;
            audio.currentTime = 0;
            const playback = audio.play();
            if (playback && typeof playback.catch === 'function') {
              playback.catch(() => {});
            }
          };

          const playForAction = (actionKey) => {
            const effects = ACTION_SOUNDS[actionKey];
            if (Array.isArray(effects) && effects.length > 0) {
              effects.forEach(effect => playEffect(effect));
            } else {
              playEffect(actionKey);
            }
          };

          return {
            playEffect,
            playForAction
          };
        };

        const CatTamagotchi = () => {
          const [gameState, setGameState] = useState({
            happiness: 75,
            energy: 60,
            hunger: 40,
            mood: 'content',
            lastInteraction: Date.now()
          });

          const economyInitialRef = useRef(loadEconomyState());
          const [coins, setCoins] = useState(economyInitialRef.current.coins);
          const [inventory, setInventory] = useState(economyInitialRef.current.inventory);
          const [decorations, setDecorations] = useState(economyInitialRef.current.decorations);
          const [isStoreOpen, setIsStoreOpen] = useState(false);
          const [storeMessage, setStoreMessage] = useState('');

          const [cats, setCats] = useState([
            {
              name: 'Lukis',
              type: 'tuxedo',
              position: { x: 25, y: 60 },
              direction: 1,
              actionState: 'idle',
              tilt: 0,
              bobOffset: 0,
              eyeColor: 'bg-amber-300'
            },
            {
              name: 'Arwen',
              type: 'gris',
              position: { x: 50, y: 70 },
              direction: -1,
              actionState: 'idle',
              tilt: 0,
              bobOffset: 0,
              eyeColor: 'bg-slate-200'
            },
            {
              name: 'Iria',
              type: 'siamese',
              position: { x: 75, y: 65 },
              direction: 1,
              actionState: 'idle',
              tilt: 0,
              bobOffset: 0,
              eyeColor: 'bg-blue-500'
            }
          ]);

          const [isAnimating, setIsAnimating] = useState(false);
          const [currentAction, setCurrentAction] = useState('');
          const [isGameMenuOpen, setIsGameMenuOpen] = useState(false);
          const [activeGame, setActiveGame] = useState(null);
          const [isNightTime, setIsNightTime] = useState(false);
          const [canInstall, setCanInstall] = useState(false);
          const [installStatus, setInstallStatus] = useState('');
          const [isStandalone, setIsStandalone] = useState(false);
          const [isIosDevice, setIsIosDevice] = useState(false);
          const notificationsSupported = typeof window !== 'undefined' && typeof Notification === 'function';
          const [notificationsEnabled, setNotificationsEnabled] = useState(false);
          const [notificationStatus, setNotificationStatus] = useState('');
          const backgroundMusicRef = useRef(null);
          const [isMusicPlaying, setIsMusicPlaying] = useState(false);
          const soundControllerRef = useRef(typeof window !== 'undefined' ? createSoundController() : null);
          const installPromptRef = useRef(null);
          const installStatusTimeoutRef = useRef(null);
          const notificationStatusTimeoutRef = useRef(null);
          const reminderTimeoutRef = useRef(null);
          const primaryCatName = cats[0]?.name || 'Tu gatito';

          useEffect(() => {
            if (typeof window === 'undefined') {
              return;
            }
            try {
              const payload = JSON.stringify({ coins, inventory, decorations });
              window.localStorage.setItem(ECONOMY_STORAGE_KEY, payload);
            } catch (error) {
              console.warn('No se pudo guardar la econom√≠a de la tienda', error);
            }
          }, [coins, inventory, decorations]);

          useEffect(() => {
            if (!storeMessage) return undefined;
            const timeout = setTimeout(() => {
              setStoreMessage('');
            }, 3200);
            return () => clearTimeout(timeout);
          }, [storeMessage]);

          useEffect(() => {
            const audio = backgroundMusicRef.current;
            if (!audio) {
              return undefined;
            }
            audio.loop = true;
            audio.volume = 0.35;
            const handlePlay = () => setIsMusicPlaying(true);
            const handlePause = () => setIsMusicPlaying(false);
            audio.addEventListener('play', handlePlay);
            audio.addEventListener('pause', handlePause);
            return () => {
              audio.removeEventListener('play', handlePlay);
              audio.removeEventListener('pause', handlePause);
              audio.pause();
              audio.currentTime = 0;
            };
          }, []);

          const handleToggleMusic = useCallback(() => {
            const audio = backgroundMusicRef.current;
            if (!audio) {
              return;
            }
            if (isMusicPlaying) {
              audio.pause();
              setIsMusicPlaying(false);
              return;
            }
            audio.currentTime = 0;
            const playback = audio.play();
            if (playback && typeof playback.then === 'function') {
              playback
                .then(() => {
                  setIsMusicPlaying(true);
                })
                .catch(() => {
                  setIsMusicPlaying(false);
                });
            } else {
              setIsMusicPlaying(true);
            }
          }, [isMusicPlaying]);

          const openGameMenu = useCallback(() => {
            setIsGameMenuOpen(true);
            setActiveGame(null);
            setGameState((prev) => ({
              ...prev,
              happiness: clamp(prev.happiness + 5, 0, 100),
              lastInteraction: Date.now()
            }));
          }, []);

          const handleCloseMenu = useCallback(() => {
            setIsGameMenuOpen(false);
            setActiveGame(null);
          }, []);

          const handleSelectGame = useCallback((gameId) => {
            setActiveGame(gameId);
            setIsGameMenuOpen(false);
            setGameState((prev) => ({
              ...prev,
              happiness: clamp(prev.happiness + 8, 0, 100),
              energy: clamp(prev.energy - 5, 0, 100),
              lastInteraction: Date.now()
            }));
          }, []);

          const closeGameExperience = useCallback(() => {
            setActiveGame(null);
            setIsGameMenuOpen(false);
            setGameState((prev) => ({
              ...prev,
              happiness: clamp(prev.happiness + 3, 0, 100),
              lastInteraction: Date.now()
            }));
          }, []);

          const openStore = useCallback(() => {
            setIsStoreOpen(true);
          }, []);

          const closeStore = useCallback(() => {
            setIsStoreOpen(false);
          }, []);

          const handlePurchaseItem = useCallback((item) => {
            if (coins < item.price) {
              setStoreMessage('Necesitas m√°s monedas para esa compra.');
              return;
            }
            setCoins((prev) => prev - item.price);
            setInventory((prev) => {
              const safePrev = prev || {};
              const owned = safePrev[item.id] || 0;
              return { ...safePrev, [item.id]: owned + 1 };
            });
            if (item.type === 'furniture') {
              setDecorations((prev) => [...prev, item.id]);
              setStoreMessage(`${primaryCatName} estrena ${item.name}.`);
            } else if (item.type === 'toy') {
              setStoreMessage(`${primaryCatName} no puede esperar para jugar con ${item.name}.`);
            } else {
              setStoreMessage(`${primaryCatName} huele ${item.name}. ¬°Qu√© delicia!`);
            }
          }, [coins, primaryCatName]);

          const handleUseItem = useCallback((item) => {
            if (item.type === 'furniture') {
              setStoreMessage('Esa decoraci√≥n ya est√° colocada en la habitaci√≥n.');
              return;
            }
            const owned = inventory?.[item.id] || 0;
            if (owned <= 0) {
              setStoreMessage('No te queda ninguna unidad de ese art√≠culo.');
              return;
            }
            const isDecoration = item.type === 'furniture';
            const baseEffect = item.effect || {};
            let hungerBoost = Number(baseEffect.hunger) || 0;
            let energyBoost = Number(baseEffect.energy) || 0;
            let happinessBoost = Number(baseEffect.happiness) || 0;
            if (!isDecoration && hungerBoost === 0 && happinessBoost === 0) {
              happinessBoost = 6;
            }
            setInventory((prev) => {
              const safePrev = prev || {};
              const current = safePrev[item.id] || 0;
              const next = { ...safePrev };
              const remaining = current - 1;
              if (remaining <= 0) {
                delete next[item.id];
              } else {
                next[item.id] = remaining;
              }
              return next;
            });
            setGameState((prev) => {
              const hunger = clamp(prev.hunger + hungerBoost, 0, 100);
              const energy = clamp(prev.energy + energyBoost, 0, 100);
              const happiness = clamp(prev.happiness + happinessBoost, 0, 100);
              return {
                ...prev,
                hunger,
                energy,
                happiness,
                mood: computeMoodFromStats(happiness, energy, hunger),
                lastInteraction: Date.now()
              };
            });
            const enjoymentText = item.type === 'toy'
              ? `${primaryCatName} jug√≥ con ${item.name}.`
              : `${primaryCatName} disfrut√≥ ${item.name}.`;
            setStoreMessage(enjoymentText);
          }, [inventory, primaryCatName]);

          const handleResetStore = useCallback(() => {
            let proceed = true;
            if (typeof window !== 'undefined' && typeof window.confirm === 'function') {
              proceed = window.confirm('¬øSeguro que quieres reiniciar la tienda? Se borrar√°n las compras y decoraciones.');
            }
            if (!proceed) {
              return;
            }
            setCoins(DEFAULT_ECONOMY_STATE.coins);
            setInventory({});
            setDecorations([]);
            setStoreMessage('La tienda se ha reiniciado. ¬°Todo vuelve a estar disponible!');
          }, []);

          const handleGameReward = useCallback((gameId, scoreValue) => {
            if (!Number.isFinite(scoreValue) || scoreValue <= 0) {
              return;
            }
            let reward = 0;
            const gameDefinition = GAME_DEFINITIONS.find((game) => game.id === gameId);
            switch (gameId) {
              case 'flappy-lukis':
                reward = Math.max(6, Math.round(scoreValue * 2.5));
                break;
              case 'lukis-sky-jump':
                reward = Math.max(6, Math.round(scoreValue * 1.8));
                break;
              case 'lukis-treat-dash':
                reward = Math.max(8, Math.round(scoreValue * 2));
                break;
              default:
                reward = Math.max(4, Math.round(scoreValue));
            }
            reward = Math.min(reward, 250);
            if (reward <= 0) {
              return;
            }
            setCoins((prev) => prev + reward);
            setGameState((prev) => {
              const happiness = clamp(prev.happiness + Math.min(12, Math.round(reward / 4)), 0, 100);
              const mood = computeMoodFromStats(happiness, prev.energy, prev.hunger);
              return {
                ...prev,
                happiness,
                mood,
                lastInteraction: Date.now()
              };
            });
            const gameName = gameDefinition?.title || 'el minijuego';
            setStoreMessage(`Ganaste ${reward} monedas ü™ô jugando ${gameName}.`);
          }, []);

          const showInstallStatus = useCallback((message) => {
            setInstallStatus(message);
            if (installStatusTimeoutRef.current) {
              clearTimeout(installStatusTimeoutRef.current);
            }
            installStatusTimeoutRef.current = setTimeout(() => {
              setInstallStatus('');
              installStatusTimeoutRef.current = null;
            }, 6000);
          }, []);

          const showNotificationStatus = useCallback((message) => {
            setNotificationStatus(message);
            if (notificationStatusTimeoutRef.current) {
              clearTimeout(notificationStatusTimeoutRef.current);
            }
            notificationStatusTimeoutRef.current = setTimeout(() => {
              setNotificationStatus('');
              notificationStatusTimeoutRef.current = null;
            }, 6000);
          }, []);

          const updateBackgroundReminderRegistration = useCallback(
            async (enabled, lastInteraction) => {
              if (!notificationsSupported || typeof navigator === 'undefined' || !navigator.serviceWorker) {
                return;
              }
              try {
                const registration = await navigator.serviceWorker.ready;
                const supportsPeriodicSync = 'periodicSync' in registration;
                const permissionGranted = Notification.permission === 'granted';
                const shouldEnable = Boolean(enabled && permissionGranted);

                if (supportsPeriodicSync) {
                  try {
                    const tags = await registration.periodicSync.getTags();
                    const alreadyRegistered = tags.includes(REMINDER_SYNC_TAG);
                    if (shouldEnable && !alreadyRegistered) {
                      await registration.periodicSync.register(REMINDER_SYNC_TAG, { minInterval: REMINDER_DELAY_MS });
                    } else if (!shouldEnable && alreadyRegistered) {
                      await registration.periodicSync.unregister(REMINDER_SYNC_TAG);
                    }
                  } catch (error) {
                    console.warn('No se pudo actualizar el registro de recordatorios en segundo plano', error);
                  }
                }

                const payload = {
                  enabled: shouldEnable,
                  name: primaryCatName,
                  url: typeof window !== 'undefined' ? window.location.href : './'
                };
                if (typeof lastInteraction === 'number' && Number.isFinite(lastInteraction)) {
                  payload.lastInteraction = lastInteraction;
                }

                await sendMessageToServiceWorker({ type: 'REMINDER_UPDATE', payload });
              } catch (error) {
                console.warn('No se pudo sincronizar la configuraci√≥n de recordatorios', error);
              }
            },
            [notificationsSupported, primaryCatName]
          );

          const showReminderNotification = useCallback(async () => {
            if (!notificationsEnabled || !notificationsSupported || Notification.permission !== 'granted') {
              return;
            }
            const catName = primaryCatName;
            const title = `¬°${catName} te echa de menos!`;
            const body = `${catName} quiere que vuelvas a jugar un ratito.`;
            const options = {
              body,
              icon: 'icons/caticon/icon.png',
              badge: 'icons/caticon/icon.png',
              tag: 'catagotchi-recordatorio',
              renotify: true,
              data: { url: typeof window !== 'undefined' ? window.location.href : './' }
            };
            try {
              if (typeof navigator !== 'undefined' && navigator.serviceWorker) {
                const registration = await navigator.serviceWorker.ready;
                if (registration?.showNotification) {
                  await registration.showNotification(title, options);
                } else {
                  new Notification(title, options);
                }
              } else {
                new Notification(title, options);
              }
            } catch (error) {
              console.error('No se pudo mostrar el recordatorio', error);
            } finally {
              const now = Date.now();
              setGameState((prev) => ({ ...prev, lastInteraction: now }));
              updateBackgroundReminderRegistration(true, now);
            }
          }, [notificationsEnabled, notificationsSupported, primaryCatName, updateBackgroundReminderRegistration]);

          const handleToggleNotifications = useCallback(async () => {
            if (!notificationsSupported) {
              showNotificationStatus('Tu dispositivo no admite notificaciones.');
              return;
            }
            if (notificationsEnabled) {
              setNotificationsEnabled(false);
              showNotificationStatus('Recordatorios en pausa.');
              await updateBackgroundReminderRegistration(false, Date.now());
              return;
            }
            let permission = Notification.permission;
            if (permission === 'default') {
              try {
                permission = await Notification.requestPermission();
              } catch (error) {
                permission = Notification.permission;
              }
            }
            if (permission !== 'granted') {
              setNotificationsEnabled(false);
              showNotificationStatus('Activa las notificaciones desde los ajustes del navegador.');
              await updateBackgroundReminderRegistration(false, Date.now());
              return;
            }
            const now = Date.now();
            setNotificationsEnabled(true);
            setGameState((prev) => ({ ...prev, lastInteraction: now }));
            showNotificationStatus(`${primaryCatName} te avisar√° cuando necesite mimos.`);
            await updateBackgroundReminderRegistration(true, now);
          }, [notificationsSupported, notificationsEnabled, showNotificationStatus, updateBackgroundReminderRegistration, primaryCatName]);

          const playActionSound = useCallback((actionKey) => {
            const controller = soundControllerRef.current;
            if (!controller) return;
            controller.playForAction(actionKey);
          }, []);

          const playGameMovementSound = useCallback(() => {
            const controller = soundControllerRef.current;
            if (!controller) return;
            controller.playEffect('gameMove');
          }, []);

          const handleCatGameInteract = useCallback(() => {
            playActionSound('play');
          }, [playActionSound]);

          useEffect(() => {
            if (typeof window === 'undefined') {
              return undefined;
            }
            setIsIosDevice(/iphone|ipad|ipod/i.test(window.navigator.userAgent || ''));
            return () => {
              if (installStatusTimeoutRef.current) {
                clearTimeout(installStatusTimeoutRef.current);
              }
              if (notificationStatusTimeoutRef.current) {
                clearTimeout(notificationStatusTimeoutRef.current);
              }
              if (reminderTimeoutRef.current) {
                clearTimeout(reminderTimeoutRef.current);
              }
            };
          }, []);

          useEffect(() => {
            if (typeof navigator !== 'undefined' && 'serviceWorker' in navigator) {
              navigator.serviceWorker.register('./service-worker.js').catch(() => {});
            }
          }, []);

          useEffect(() => {
            if (!notificationsSupported) {
              return;
            }
            if (notificationsEnabled && Notification.permission !== 'granted') {
              setNotificationsEnabled(false);
              updateBackgroundReminderRegistration(false, Date.now());
            }
          }, [notificationsEnabled, notificationsSupported, updateBackgroundReminderRegistration]);

          useEffect(() => {
            if (typeof window === 'undefined' || !notificationsSupported) {
              return;
            }
            try {
              const stored = window.localStorage.getItem('catagotchi-reminders');
              if (stored === 'on' && Notification.permission === 'granted') {
                setNotificationsEnabled(true);
              }
            } catch (error) {
              console.warn('No se pudo restaurar la configuraci√≥n de recordatorios', error);
            }
          }, [notificationsSupported]);

          useEffect(() => {
            if (typeof window === 'undefined') {
              return;
            }
            try {
              window.localStorage.setItem('catagotchi-reminders', notificationsEnabled ? 'on' : 'off');
            } catch (error) {
              console.warn('No se pudo guardar la configuraci√≥n de recordatorios', error);
            }
          }, [notificationsEnabled]);

          useEffect(() => {
            if (!notificationsEnabled || !notificationsSupported || Notification.permission !== 'granted') {
              if (reminderTimeoutRef.current) {
                clearTimeout(reminderTimeoutRef.current);
                reminderTimeoutRef.current = null;
              }
              return;
            }
            const now = Date.now();
            const lastInteraction = gameState.lastInteraction || now;
            const elapsed = now - lastInteraction;
            const delay = Math.max(REMINDER_MIN_DELAY_MS, REMINDER_DELAY_MS - elapsed);
            if (reminderTimeoutRef.current) {
              clearTimeout(reminderTimeoutRef.current);
            }
            reminderTimeoutRef.current = setTimeout(() => {
              reminderTimeoutRef.current = null;
              showReminderNotification();
            }, delay);

            return () => {
              if (reminderTimeoutRef.current) {
                clearTimeout(reminderTimeoutRef.current);
                reminderTimeoutRef.current = null;
              }
            };
          }, [notificationsEnabled, notificationsSupported, gameState.lastInteraction, showReminderNotification]);

          useEffect(() => {
            updateBackgroundReminderRegistration(notificationsEnabled, gameState.lastInteraction);
          }, [notificationsEnabled, gameState.lastInteraction, updateBackgroundReminderRegistration]);

          useEffect(() => {
            if (typeof window === 'undefined') {
              return undefined;
            }
            const updateTimeOfDay = () => {
              const hour = new Date().getHours();
              setIsNightTime(hour < 6 || hour >= 20);
            };
            updateTimeOfDay();
            const timeInterval = setInterval(updateTimeOfDay, 60000);
            return () => clearInterval(timeInterval);
          }, []);

          useEffect(() => {
            if (typeof window === 'undefined') {
              return undefined;
            }
            const handleBeforeInstallPrompt = (event) => {
              event.preventDefault();
              installPromptRef.current = event;
              setCanInstall(true);
            };

            const handleAppInstalled = () => {
              installPromptRef.current = null;
              setCanInstall(false);
              setIsStandalone(true);
              showInstallStatus('Catagotchi est√° en tu pantalla de inicio üêæ');
            };

            window.addEventListener('beforeinstallprompt', handleBeforeInstallPrompt);
            window.addEventListener('appinstalled', handleAppInstalled);

            return () => {
              window.removeEventListener('beforeinstallprompt', handleBeforeInstallPrompt);
              window.removeEventListener('appinstalled', handleAppInstalled);
            };
          }, [showInstallStatus]);

          useEffect(() => {
            if (typeof window === 'undefined' || typeof window.matchMedia !== 'function') {
              return undefined;
            }
            const mediaQuery = window.matchMedia('(display-mode: standalone)');

            const updateStandalone = () => {
              const navigatorStandalone =
                typeof window.navigator !== 'undefined' && 'standalone' in window.navigator
                  ? window.navigator.standalone
                  : false;
              const standalone = mediaQuery.matches || Boolean(navigatorStandalone);
              setIsStandalone(standalone);
            };

            updateStandalone();

            if (typeof mediaQuery.addEventListener === 'function') {
              mediaQuery.addEventListener('change', updateStandalone);
            } else if (typeof mediaQuery.addListener === 'function') {
              mediaQuery.addListener(updateStandalone);
            }

            return () => {
              if (typeof mediaQuery.removeEventListener === 'function') {
                mediaQuery.removeEventListener('change', updateStandalone);
              } else if (typeof mediaQuery.removeListener === 'function') {
                mediaQuery.removeListener(updateStandalone);
              }
            };
          }, []);

          useEffect(() => {
            const moveInterval = setInterval(() => {
              if (gameState.mood === 'tired' || isAnimating) return;
              setCats(prevCats =>
                prevCats.map(cat => {
                  const step = Math.random() * 4 + 2;
                  let newX = cat.position.x + cat.direction * step;
                  let newDirection = cat.direction;
                  if (newX <= 12) {
                    newX = 12;
                    newDirection = 1;
                  } else if (newX >= 88) {
                    newX = 88;
                    newDirection = -1;
                  }
                  if (Math.random() < 0.25) {
                    newDirection *= -1;
                  }
                  const newY = clamp(cat.position.y + (Math.random() - 0.5) * 4, 55, 78);
                  const tilt = clamp((Math.random() - 0.5) * 12, -8, 8);
                  const bobOffset = clamp((Math.random() - 0.5) * 8, -4, 4);
                  return {
                    ...cat,
                    position: { x: newX, y: newY },
                    direction: newDirection,
                    tilt,
                    bobOffset
                  };
                })
              );
            }, 1400);
            return () => clearInterval(moveInterval);
          }, [gameState.mood, isAnimating]);

          useEffect(() => {
            const interval = setInterval(() => {
              setGameState(prevState => {
                const newHunger = Math.max(0, prevState.hunger - 5);
                const newEnergy = Math.max(0, prevState.energy - 5);
                const newHappiness = Math.max(0, prevState.happiness - 5);
                return {
                  ...prevState,
                  hunger: newHunger,
                  energy: newEnergy,
                  happiness: newHappiness,
                  mood: computeMoodFromStats(newHappiness, newEnergy, newHunger)
                };
              });
            }, 3000);
            return () => clearInterval(interval);
          }, []);

          const handleAction = (action) => {
            if (isAnimating) return;
            setIsAnimating(true);
            setCurrentAction(action);
            playActionSound(action);
            setCats(prevCats =>
              prevCats.map(cat => ({
                ...cat,
                actionState: action
              }))
            );
            setTimeout(() => {
              setGameState(prevState => {
                let newState = { ...prevState, lastInteraction: Date.now() };
                switch (action) {
                  case 'feed':
                    newState.hunger = Math.min(100, prevState.hunger + 30);
                    newState.happiness = Math.min(100, prevState.happiness + 15);
                    break;
                  case 'play':
                    newState.energy = Math.max(20, prevState.energy - 15);
                    newState.happiness = Math.min(100, prevState.happiness + 25);
                    newState.hunger = Math.max(0, prevState.hunger - 10);
                    break;
                  case 'sleep':
                    newState.energy = Math.min(100, prevState.energy + 40);
                    newState.hunger = Math.max(0, prevState.hunger - 5);
                    break;
                  default:
                    break;
                }
                newState.mood = computeMoodFromStats(newState.happiness, newState.energy, newState.hunger);
                return newState;
              });
              setCats(prevCats => 
                prevCats.map(cat => ({
                  ...cat,
                  actionState: 'idle'
                }))
              );
              setIsAnimating(false);
              setCurrentAction('');
            }, 2500);
          };

          const handleInstallClick = useCallback(async () => {
            if (installPromptRef.current) {
              try {
                installPromptRef.current.prompt();
                const choice = await installPromptRef.current.userChoice;
                if (choice?.outcome === 'accepted') {
                  showInstallStatus('¬°Listo! Busca Catagotchi en tu pantalla de inicio.');
                } else {
                  showInstallStatus('Puedes a√±adir Catagotchi m√°s tarde desde el men√∫ de tu navegador.');
                }
              } catch (error) {
                showInstallStatus('No se pudo completar la instalaci√≥n. Int√©ntalo de nuevo m√°s tarde.');
              } finally {
                installPromptRef.current = null;
                setCanInstall(false);
              }
              return;
            }

            if (isIosDevice) {
              showInstallStatus('Pulsa el bot√≥n Compartir y elige "A√±adir a pantalla de inicio".');
            } else {
              showInstallStatus('Busca "A√±adir a pantalla de inicio" en el men√∫ de tu navegador.');
            }
          }, [isIosDevice, showInstallStatus]);

          const showQuickInstallButton = !isStandalone && (canInstall || isIosDevice);
          const shouldShowInstallButton = !isStandalone;

          const getStatColor = (value) => {
            if (value > 70) return 'bg-green-500';
            if (value > 40) return 'bg-yellow-500';
            return 'bg-red-500';
          };

          const getMoodEmoji = (mood) => {
            switch (mood) {
              case 'happy': return 'üò∏';
              case 'content': return 'üò∫';
              case 'hungry': return 'üôÄ';
              case 'tired': return 'üò¥';
              case 'sad': return 'üòø';
              default: return 'üò∏';
            }
          };

          const getCatDisplay = (cat) => {
            const transformParts = ['translate(-50%, -50%)'];
            if (cat.direction < 0) transformParts.push('scaleX(-1)');
            if (cat.bobOffset) transformParts.push(`translateY(${cat.bobOffset}px)`);
            if (cat.tilt) transformParts.push(`rotate(${cat.tilt}deg)`);
            const transform = transformParts.join(' ');
            let extraElements = null;
            const avgStats = (gameState.happiness + gameState.energy + gameState.hunger) / 3;

            switch (cat.actionState) {
              case 'feed':
                extraElements = (
                  <div className="absolute -top-8 left-1/2 transform -translate-x-1/2">
                    <div className="text-lg animate-bounce">ü•õ</div>
                  </div>
                );
                break;
              case 'play':
                extraElements = (
                  <div className="absolute -top-8 left-1/2 transform -translate-x-1/2">
                    <div className="text-lg animate-pulse">üê≠</div>
                  </div>
                );
                break;
              case 'sleep':
                extraElements = (
                  <div className="absolute -top-6 left-1/2 transform -translate-x-1/2">
                    <div className="text-lg animate-pulse">üí§</div>
                  </div>
                );
                break;
              default:
                if (avgStats < 60) {
                  let angerEmoji = null;
                  if (avgStats < 20) angerEmoji = 'üò°';
                  else if (avgStats < 40) angerEmoji = 'üò†';
                  else angerEmoji = 'üò§';
                  extraElements = (
                    <div className="absolute -top-6 left-1/2 transform -translate-x-1/2">
                      <div className="text-lg animate-bounce">{angerEmoji}</div>
                    </div>
                  );
                }
                break;
            }

            return (
              <div
                className="absolute transition-all duration-1000"
                style={{ left: `${cat.position.x}%`, top: `${cat.position.y}%`, transform }}
              >
                <CatAvatar
                  type={cat.type}
                  eyeColorClass={cat.eyeColor}
                  name={cat.name}
                  isSleeping={cat.actionState === 'sleep'}
                />
                {extraElements}
              </div>
            );
          };

          const activeGameDefinition = activeGame
            ? GAME_DEFINITIONS.find((game) => game.id === activeGame)
            : null;

          return (
            <div className="min-h-screen bg-gradient-to-br from-purple-400 via-pink-300 to-yellow-300 p-4">
              <audio
                ref={backgroundMusicRef}
                src="./YTDown.com_YouTube_Pou-music-ost-Connect-Cliff-Jump-Cliff-D_Media_mlucomKKlwk_001_720p.mp3"
                preload="auto"
                aria-hidden="true"
                className="hidden"
              ></audio>
              <div className="max-w-md mx-auto bg-white rounded-3xl shadow-2xl overflow-hidden">
                <div className={`relative h-64 ${isNightTime ? 'bg-gradient-to-b from-indigo-900 to-purple-900' : 'bg-gradient-to-b from-blue-100 to-green-200'} overflow-hidden transition-all duration-1000`}>
                  <div className="absolute bottom-0 w-full h-12 bg-amber-200"></div>
                  <div className="absolute left-0 top-0 w-2 h-full bg-amber-300"></div>
                  <div className="absolute right-0 top-0 w-2 h-full bg-amber-300"></div>
                  <div className="absolute top-0 w-full h-2 bg-amber-300"></div>

                  <div className="absolute top-4 right-4 w-24 h-20 bg-sky-200 border-4 border-amber-600 rounded">
                    <div className={`absolute inset-1 ${isNightTime ? 'bg-indigo-900' : 'bg-sky-100'} transition-all duration-1000`}>
                      <div className="w-full h-0.5 bg-amber-600 absolute top-1/2 transform -translate-y-1/2"></div>
                      <div className="h-full w-0.5 bg-amber-600 absolute left-1/2 transform -translate-x-1/2"></div>
                      {isNightTime ? (
                        <>
                          <div className="absolute top-2 right-2 w-6 h-6 bg-yellow-100 rounded-full shadow-lg"></div>
                          <div className="absolute top-1 left-2 text-yellow-200 text-xs">‚ú¶</div>
                        </>
                      ) : (
                        <>
                          <div className="absolute top-2 left-2 w-8 h-8 bg-yellow-400 rounded-full animate-pulse"></div>
                          <div className="absolute top-1 right-1 w-4 h-2 bg-white rounded-full opacity-70"></div>
                        </>
                      )}
                    </div>
                    <div className="absolute -top-1 -left-2 w-5 h-20 bg-pink-300 rounded-r-lg"></div>
                    <div className="absolute -top-1 -right-2 w-5 h-20 bg-pink-300 rounded-l-lg"></div>
                  </div>

                  <figure
                    className="absolute top-6 left-6 w-24 h-28 rounded-xl shadow-lg overflow-hidden"
                    aria-labelledby="lukis-portrait-caption"
                  >
                    <div className="relative h-full w-full">
                      <div className="absolute inset-0 rounded-xl bg-gradient-to-br from-amber-200 via-amber-300 to-amber-100 border-4 border-amber-700"></div>
                      <div className="absolute inset-1 rounded-lg border-2 border-amber-500 bg-amber-50/70"></div>
                      <img
                        src="IMG-20250924-WA0178.jpg"
                        alt="Retrato de Lukis enmarcado"
                        loading="lazy"
                        className="absolute inset-2 w-[calc(100%-1rem)] h-[calc(100%-1rem)] object-cover rounded-md"
                      />
                    </div>
                    <figcaption
                      id="lukis-portrait-caption"
                      className="sr-only"
                    >
                      Lukis posa con un mo√±o rojo en un retrato familiar.
                    </figcaption>
                  </figure>

                  <div className="absolute bottom-12 left-4 w-12 h-6 bg-red-400 rounded-full border-2 border-red-500"></div>
                  <div className="absolute bottom-12 right-8 w-6 h-3 bg-gray-300 rounded-full border border-gray-400"></div>
                  <div className="absolute bottom-12 right-16 w-6 h-3 bg-gray-300 rounded-full border border-gray-400"></div>
                  <div className="absolute bottom-12 right-24 w-6 h-3 bg-gray-300 rounded-full border border-gray-400"></div>
                  <div className="absolute bottom-12 left-1/4 w-36 h-10 bg-purple-300 rounded-lg opacity-60"></div>

                  {decorations.map((decorId, index) => {
                    const config = DECORATION_CONFIG[decorId];
                    if (!config) return null;
                    const style = {
                      position: 'absolute',
                      ...(typeof config.style === 'function' ? config.style(index) : config.style)
                    };
                    let content = null;
                    if (config.image) {
                      content = (
                        <img
                          src={config.image}
                          alt={config.imageAlt || ''}
                          loading="lazy"
                          className={config.imageClassName || 'h-16 w-16 object-contain'}
                        />
                      );
                    } else if (config.emoji) {
                      content = (
                        <span className={config.emojiClassName || ''} aria-hidden="true">
                          {config.emoji}
                        </span>
                      );
                    } else if (typeof config.render === 'function') {
                      content = config.render({ index });
                    }
                    if (!content) return null;
                    return (
                      <div
                        key={`${decorId}-${index}`}
                        className={`pointer-events-none select-none ${config.className || ''}`}
                        style={style}
                        aria-hidden="true"
                      >
                        {content}
                      </div>
                    );
                  })}

                  {cats.map((cat, index) => (
                    <div key={index}>{getCatDisplay(cat)}</div>
                  ))}
                </div>

                <div className="p-4 text-center bg-gray-50">
                  <div className="flex justify-center items-center space-x-2 mb-2">
                    <span className="text-lg">{getMoodEmoji(gameState.mood)}</span>
                    <span className="text-sm text-gray-600 capitalize">
                      Estado: {gameState.mood === 'happy' ? 'Felices' : 
                             gameState.mood === 'content' ? 'Tranquilos' :
                             gameState.mood === 'hungry' ? 'Hambrientos' :
                             gameState.mood === 'tired' ? 'Cansados' :
                             gameState.mood === 'sad' ? 'Tristes' : 'Juguetones'}
                    </span>
                  </div>
                  <div className="flex justify-center items-center space-x-2">
                    <span className="text-base" role="img" aria-hidden="true">
                      {isNightTime ? 'üåô' : '‚òÄÔ∏è'}
                    </span>
                    <span className="text-xs text-gray-500">
                      {isNightTime ? 'Hora de dormir' : 'D√≠a activo'}
                    </span>
                  </div>
                </div>

                <div className="px-6 pb-6 space-y-3">
                  <div className="flex items-center space-x-3">
                    <span className="text-red-500 text-xl" role="img" aria-hidden="true">‚ù§Ô∏è</span>
                    <div className="flex-1">
                      <div className="flex justify-between text-sm mb-1">
                        <span className="font-medium">Felicidad</span>
                        <span>{Math.round(gameState.happiness)}%</span>
                      </div>
                      <div className="w-full bg-gray-200 rounded-full h-2">
                        <div
                          className={`h-2 rounded-full transition-all duration-500 ${getStatColor(gameState.happiness)}`}
                          style={{ width: `${gameState.happiness}%` }}
                        ></div>
                      </div>
                    </div>
                  </div>

                  <div className="flex items-center space-x-3">
                    <span className="text-green-500 text-xl" role="img" aria-hidden="true">üîã</span>
                    <div className="flex-1">
                      <div className="flex justify-between text-sm mb-1">
                        <span className="font-medium">Energ√≠a</span>
                        <span>{Math.round(gameState.energy)}%</span>
                      </div>
                      <div className="w-full bg-gray-200 rounded-full h-2">
                        <div
                          className={`h-2 rounded-full transition-all duration-500 ${getStatColor(gameState.energy)}`}
                          style={{ width: `${gameState.energy}%` }}
                        ></div>
                      </div>
                    </div>
                  </div>

                  <div className="flex items-center space-x-3">
                    <span className="text-yellow-600 text-xl" role="img" aria-hidden="true">üçó</span>
                    <div className="flex-1">
                      <div className="flex justify-between text-sm mb-1">
                        <span className="font-medium">Hambre</span>
                        <span>{Math.round(gameState.hunger)}%</span>
                      </div>
                      <div className="w-full bg-gray-200 rounded-full h-2">
                        <div
                          className={`h-2 rounded-full transition-all duration-500 ${
                            gameState.hunger < 30 ? 'bg-red-500' :
                            gameState.hunger < 60 ? 'bg-yellow-500' : 'bg-green-500'
                          }`}
                          style={{ width: `${gameState.hunger}%` }}
                        ></div>
                      </div>
                    </div>
                  </div>
                </div>

                <div className="px-6 pb-4 flex items-center justify-between">
                  <div className="flex items-center space-x-3">
                    <span className="text-2xl" aria-hidden="true">ü™ô</span>
                    <div>
                      <p className="text-sm font-semibold text-yellow-600">{coins} monedas</p>
                      <p className="text-[11px] text-gray-500">Gana jugando para mimarlos a√∫n m√°s.</p>
                    </div>
                  </div>
                  <button
                    onClick={openStore}
                    className="px-4 py-2 text-xs font-semibold rounded-full bg-yellow-500 text-white hover:bg-yellow-600 transition shadow"
                  >
                    Abrir tienda
                  </button>
                </div>

                <div className="px-6 pt-4 pb-5 bg-gray-50">
                  <div className="grid grid-cols-4 gap-3">
                    <button
                      onClick={() => handleAction('feed')}
                      disabled={isAnimating}
                      className="flex w-full flex-col items-center space-y-1.5 px-3 py-2.5 bg-green-500 hover:bg-green-600 disabled:bg-gray-400 text-white rounded-2xl transition-all duration-300 transform hover:scale-105 disabled:scale-100"
                    >
                      <span className="text-2xl" role="img" aria-hidden="true">üç≤</span>
                      <span className="text-[11px] font-medium">Comer</span>
                    </button>

                    <button
                      onClick={() => handleAction('play')}
                      disabled={isAnimating}
                      className="flex w-full flex-col items-center space-y-1.5 px-3 py-2.5 bg-blue-500 hover:bg-blue-600 disabled:bg-gray-400 text-white rounded-2xl transition-all duration-300 transform hover:scale-105 disabled:scale-100"
                    >
                      <span className="text-2xl" role="img" aria-hidden="true">üß∂</span>
                      <span className="text-[11px] font-medium">Jugar</span>
                    </button>

                    <button
                      onClick={() => handleAction('sleep')}
                      disabled={isAnimating}
                      className="flex w-full flex-col items-center space-y-1.5 px-3 py-2.5 bg-purple-500 hover:bg-purple-600 disabled:bg-gray-400 text-white rounded-2xl transition-all duration-300 transform hover:scale-105 disabled:scale-100"
                    >
                      <span className="text-2xl" role="img" aria-hidden="true">üåô</span>
                      <span className="text-[11px] font-medium">Dormir</span>
                    </button>
                    <button
                      onClick={() => {
                        playActionSound('play');
                        openGameMenu();
                      }}
                      className="flex w-full flex-col items-center space-y-1.5 px-3 py-2.5 bg-amber-500 hover:bg-amber-600 text-white rounded-2xl transition-all duration-300 transform hover:scale-105"
                    >
                      <span className="text-2xl" role="img" aria-hidden="true">üéÆ</span>
                      <span className="text-[11px] font-medium">Juegos</span>
                    </button>
                  </div>
                </div>

                {storeMessage && !isStoreOpen && (
                  <div className="px-6 pb-4">
                    <div className="rounded-2xl border border-amber-100 bg-amber-50 px-4 py-3 text-sm text-amber-700 text-center shadow">
                      {storeMessage}
                    </div>
                  </div>
                )}

                <div className="px-6 pb-4">
                  <div className="flex justify-center gap-4">
                    <button
                      type="button"
                      onClick={handleToggleMusic}
                      className={`w-14 h-14 rounded-full flex items-center justify-center text-2xl shadow-lg transition-all duration-300 ${
                        isMusicPlaying ? 'bg-rose-500 hover:bg-rose-600' : 'bg-rose-400 hover:bg-rose-500'
                      } text-white`}
                      aria-pressed={isMusicPlaying ? 'true' : 'false'}
                      title={isMusicPlaying ? 'Pausar m√∫sica de fondo' : 'Reproducir m√∫sica de fondo'}
                    >
                      <span aria-hidden="true">{isMusicPlaying ? 'üîá' : 'üéµ'}</span>
                      <span className="sr-only">
                        {isMusicPlaying ? 'Pausar m√∫sica de fondo' : 'Reproducir m√∫sica de fondo'}
                      </span>
                    </button>
                    {notificationsSupported && (
                      <button
                        type="button"
                        onClick={handleToggleNotifications}
                        className={`w-14 h-14 rounded-full flex items-center justify-center text-2xl shadow-lg transition-all duration-300 text-white ${
                          notificationsEnabled ? 'bg-amber-500 hover:bg-amber-600' : 'bg-amber-400 hover:bg-amber-500'
                        }`}
                        aria-pressed={notificationsEnabled ? 'true' : 'false'}
                        title={notificationsEnabled ? 'Pausar recordatorios' : 'Activar recordatorios'}
                      >
                        <span aria-hidden="true">{notificationsEnabled ? 'üîï' : 'üîî'}</span>
                        <span className="sr-only">
                          {notificationsEnabled ? 'Pausar recordatorios' : 'Activar recordatorios'}
                        </span>
                      </button>
                    )}
                    {showQuickInstallButton && (
                      <button
                        type="button"
                        onClick={handleInstallClick}
                        className="w-14 h-14 rounded-full flex items-center justify-center text-2xl shadow-lg transition-all duration-300 bg-pink-500 hover:bg-pink-600 text-white"
                        title="Guardar en pantalla de inicio (atajo r√°pido)"
                      >
                        <span aria-hidden="true">üì≤</span>
                        <span className="sr-only">Guardar Catagotchi en la pantalla de inicio</span>
                      </button>
                    )}
                  </div>
                  {notificationsSupported && !notificationsEnabled && !isStandalone && Notification?.permission !== 'granted' && (
                    <p className="mt-3 text-xs text-center text-gray-600">
                      A√±ade Catagotchi a tu pantalla de inicio para que los recordatorios funcionen mejor.
                    </p>
                  )}
                  {notificationStatus && (
                    <div className="mt-3 bg-amber-50 border border-amber-200 text-amber-700 text-sm rounded-2xl px-4 py-3 text-center">
                      {notificationStatus}
                    </div>
                  )}
                </div>

                {installStatus && (
                  <div className="px-6 pb-4">
                    <div className="bg-pink-50 border border-pink-200 text-pink-700 text-sm rounded-2xl px-4 py-3 text-center">
                      {installStatus}
                    </div>
                  </div>
                )}

                {shouldShowInstallButton && (
                  <div className="px-6 pb-6">
                    <button
                      onClick={handleInstallClick}
                      className="w-full flex items-center justify-center space-x-2 px-4 py-3 bg-pink-500 hover:bg-pink-600 text-white rounded-2xl transition-all duration-300"
                    >
                      <span className="text-xl" role="img" aria-hidden="true">üì≤</span>
                      <span className="text-sm font-semibold">Guardar en pantalla de inicio</span>
                    </button>
                    {isIosDevice && !canInstall && (
                      <p className="mt-3 text-xs text-center text-gray-600">
                        En iPhone o iPad abre el men√∫ de compartir y toca ¬´A√±adir a pantalla de inicio¬ª.
                      </p>
                    )}
                  </div>
                )}

                {currentAction && (
                  <div className="px-6 pb-6">
                    <div className="bg-purple-100 text-purple-700 rounded-2xl p-3 text-center text-sm font-medium animate-pulse">
                      Ejecutando acci√≥n: {currentAction === 'feed' ? 'Comer' : currentAction === 'play' ? 'Jugar' : 'Dormir'}...
                    </div>
                  </div>
                )}
              </div>
              {isGameMenuOpen && (
                <GameMenu onSelect={handleSelectGame} onClose={handleCloseMenu} />
              )}
              {isStoreOpen && (
                <GameOverlay title="Tienda Gatuna" onClose={closeStore}>
                  <StoreModal
                    coins={coins}
                    inventory={inventory}
                    onBuy={handlePurchaseItem}
                    onUse={handleUseItem}
                    onReset={handleResetStore}
                    message={storeMessage}
                  />
                </GameOverlay>
              )}
              {activeGame && activeGameDefinition && (
                <GameOverlay title={activeGameDefinition.title} onClose={closeGameExperience}>
                  {activeGame === 'flappy-lukis' && (
                    <FlappyLukis
                      onExit={closeGameExperience}
                      onReward={handleGameReward}
                      onCatInteract={handleCatGameInteract}
                      onMovementSound={playGameMovementSound}
                    />
                  )}
                  {activeGame === 'lukis-sky-jump' && (
                    <LukisSkyJump
                      onExit={closeGameExperience}
                      onReward={handleGameReward}
                      onCatInteract={handleCatGameInteract}
                      onMovementSound={playGameMovementSound}
                    />
                  )}
                  {activeGame === 'lukis-treat-dash' && (
                    <LukisTreatDash
                      onExit={closeGameExperience}
                      onReward={handleGameReward}
                      onCatInteract={handleCatGameInteract}
                      onMovementSound={playGameMovementSound}
                    />
                  )}
                </GameOverlay>
              )}
          </div>
        );
        };

        ReactDOM.createRoot(document.getElementById('root')).render(<CatTamagotchi />);
    </script>
</body>
</html>
