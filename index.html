<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Catagotchi</title>
    <meta name="theme-color" content="#ff85c5">
    <link rel="manifest" href="manifest.webmanifest">
    <link rel="icon" type="image/png" href="icons/caticon/icon.png">
    <link rel="apple-touch-icon" href="icons/caticon/icon.png">
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        const GAME_DEFINITIONS = [
          {
            id: 'flappy-lukis',
            title: 'Flappy Lukis',
            emoji: 'üêæ',
            description: 'Ayuda a Lukis a volar entre las nubes sin chocarse.'
          },
          {
            id: 'laser-chase',
            title: 'Caza el L√°ser',
            emoji: 'üî¥',
            description: 'Toca el punto rojo antes de que desaparezca para sumar puntos.'
          },
          {
            id: 'memory-cats',
            title: 'Memoria Gatuna',
            emoji: 'üß†',
            description: 'Encuentra las parejas de iconos gatunos en el menor n√∫mero de turnos.'
          }
        ];

        const GameOverlay = ({ title, onClose, children }) => (
          <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-60 px-4">
            <div className="w-full max-w-md bg-white rounded-3xl shadow-2xl overflow-hidden">
              <div className="flex items-center justify-between px-5 py-4 bg-gradient-to-r from-purple-500 to-pink-500 text-white">
                <h2 className="text-lg font-semibold">{title}</h2>
                <button
                  onClick={onClose}
                  className="text-white/90 hover:text-white transition"
                  aria-label="Cerrar"
                >
                  ‚úñÔ∏è
                </button>
              </div>
              <div className="p-5 space-y-4 max-h-[70vh] overflow-y-auto">{children}</div>
            </div>
          </div>
        );

        const GameMenu = ({ onSelect, onClose }) => (
          <GameOverlay title="Sala de Juegos" onClose={onClose}>
            <p className="text-sm text-gray-600">
              Elige un minijuego para que tus gatitos se diviertan y suban su felicidad.
            </p>
            <div className="grid grid-cols-1 gap-4">
              {GAME_DEFINITIONS.map((game) => (
                <button
                  key={game.id}
                  onClick={() => onSelect(game.id)}
                  className="flex items-start space-x-3 rounded-2xl border border-purple-100 bg-purple-50 hover:bg-purple-100 transition p-4 text-left"
                >
                  <span className="text-3xl" aria-hidden="true">{game.emoji}</span>
                  <div>
                    <h3 className="text-base font-semibold text-purple-700">{game.title}</h3>
                    <p className="text-sm text-gray-600">{game.description}</p>
                  </div>
                </button>
              ))}
            </div>
          </GameOverlay>
        );

        const FlappyLukis = ({ onExit }) => {
          const GAME_WIDTH = 320;
          const GAME_HEIGHT = 420;
          const BIRD_SIZE = 28;
          const BIRD_X = 60;
          const OBSTACLE_WIDTH = 60;
          const GAP_HEIGHT = 130;

          const [bird, setBird] = useState({ y: GAME_HEIGHT / 2 - BIRD_SIZE / 2, velocity: 0 });
          const [obstacles, setObstacles] = useState(() => []);
          const [score, setScore] = useState(0);
          const [isRunning, setIsRunning] = useState(false);
          const [isGameOver, setIsGameOver] = useState(false);
          const loopRef = useRef(null);

          const createObstacle = useCallback((offset = 0) => {
            const gapTop = Math.random() * (GAME_HEIGHT - GAP_HEIGHT - 120) + 60;
            return {
              x: GAME_WIDTH + offset,
              gapTop,
              gapBottom: gapTop + GAP_HEIGHT,
              passed: false
            };
          }, []);

          const stopGame = useCallback(() => {
            setIsRunning(false);
            setIsGameOver(true);
          }, []);

          const resetGame = useCallback(() => {
            setBird({ y: GAME_HEIGHT / 2 - BIRD_SIZE / 2, velocity: 0 });
            setObstacles([createObstacle(), createObstacle(GAME_WIDTH / 2 + 140)]);
            setScore(0);
            setIsGameOver(false);
            setIsRunning(true);
          }, [createObstacle]);

          useEffect(() => {
            if (!isRunning) {
              if (loopRef.current) {
                clearInterval(loopRef.current);
                loopRef.current = null;
              }
              return;
            }

            loopRef.current = setInterval(() => {
              setBird((prev) => {
                const newVelocity = prev.velocity + 0.65;
                const newY = prev.y + newVelocity;
                return { y: newY, velocity: newVelocity };
              });

              setObstacles((prevObstacles) => {
                let scoreGain = 0;
                const updated = prevObstacles
                  .map((obstacle) => {
                    const newX = obstacle.x - 4;
                    let passed = obstacle.passed;
                    if (!passed && newX + OBSTACLE_WIDTH < BIRD_X) {
                      passed = true;
                      scoreGain += 1;
                    }
                    return { ...obstacle, x: newX, passed };
                  })
                  .filter((obstacle) => obstacle.x + OBSTACLE_WIDTH > -10);

                while (updated.length < 3) {
                  const last = updated[updated.length - 1];
                  const offset = last ? last.x + 180 : GAME_WIDTH;
                  updated.push(createObstacle(offset));
                }

                if (scoreGain > 0) {
                  setScore((prevScore) => prevScore + scoreGain);
                }

                return updated;
              });
            }, 40);

            return () => {
              if (loopRef.current) {
                clearInterval(loopRef.current);
                loopRef.current = null;
              }
            };
          }, [isRunning, createObstacle]);

          useEffect(() => {
            if (!isRunning) return;

            const birdTop = bird.y;
            const birdBottom = bird.y + BIRD_SIZE;

            if (birdBottom >= GAME_HEIGHT || birdTop <= 0) {
              stopGame();
              return;
            }

            for (const obstacle of obstacles) {
              if (
                obstacle.x < BIRD_X + BIRD_SIZE &&
                obstacle.x + OBSTACLE_WIDTH > BIRD_X
              ) {
                if (birdTop < obstacle.gapTop || birdBottom > obstacle.gapBottom) {
                  stopGame();
                  break;
                }
              }
            }
          }, [bird, obstacles, isRunning, stopGame]);

          const flap = useCallback(() => {
            if (!isRunning) return;
            setBird((prev) => ({ y: prev.y, velocity: -8 }));
          }, [isRunning]);

          useEffect(() => {
            const handleKey = (event) => {
              if (event.code === 'Space') {
                event.preventDefault();
                if (isGameOver) {
                  resetGame();
                } else {
                  flap();
                }
              }
            };
            window.addEventListener('keydown', handleKey);
            return () => window.removeEventListener('keydown', handleKey);
          }, [flap, isGameOver, resetGame]);

          useEffect(() => () => {
            if (loopRef.current) {
              clearInterval(loopRef.current);
            }
          }, []);

          return (
            <div className="space-y-4">
              <div className="flex items-center justify-between text-sm text-gray-600">
                <span>Puntuaci√≥n: <span className="font-semibold text-purple-600">{score}</span></span>
                <button
                  onClick={onExit}
                  className="px-3 py-1.5 text-xs font-semibold rounded-full bg-gray-200 hover:bg-gray-300 transition"
                >
                  Salir
                </button>
              </div>
              <div
                className="relative mx-auto rounded-3xl overflow-hidden shadow-inner"
                style={{ width: GAME_WIDTH, height: GAME_HEIGHT }}
              >
                <div
                  className="absolute inset-0 bg-gradient-to-b from-sky-200 via-sky-100 to-emerald-100"
                  onClick={flap}
                  onTouchStart={(event) => {
                    event.preventDefault();
                    flap();
                  }}
                >
                  <div
                    className="absolute bg-gradient-to-br from-pink-400 to-purple-500 rounded-full shadow-lg flex items-center justify-center text-white"
                    style={{
                      left: `${BIRD_X}px`,
                      top: `${bird.y}px`,
                      width: `${BIRD_SIZE}px`,
                      height: `${BIRD_SIZE}px`
                    }}
                  >
                    üò∫
                  </div>
                  {obstacles.map((obstacle, index) => (
                    <React.Fragment key={index}>
                      <div
                        className="absolute bg-emerald-500"
                        style={{
                          left: `${obstacle.x}px`,
                          top: 0,
                          width: `${OBSTACLE_WIDTH}px`,
                          height: `${obstacle.gapTop}px`
                        }}
                      />
                      <div
                        className="absolute bg-emerald-500"
                        style={{
                          left: `${obstacle.x}px`,
                          top: `${obstacle.gapBottom}px`,
                          width: `${OBSTACLE_WIDTH}px`,
                          height: `${GAME_HEIGHT - obstacle.gapBottom}px`
                        }}
                      />
                    </React.Fragment>
                  ))}
                  {!isRunning && !isGameOver && (
                    <div className="absolute inset-0 flex flex-col items-center justify-center bg-white/70 text-center p-6 space-y-2">
                      <span className="text-4xl">üêæ</span>
                      <p className="text-base font-semibold text-purple-600">Pulsa para comenzar</p>
                      <p className="text-sm text-gray-600">Toca o presiona la barra espaciadora para que Lukis aletee.</p>
                      <button
                        onClick={resetGame}
                        className="mt-2 px-4 py-2 rounded-full bg-purple-500 text-white text-sm font-semibold hover:bg-purple-600 transition"
                      >
                        ¬°Empezar!
                      </button>
                    </div>
                  )}
                  {isGameOver && (
                    <div className="absolute inset-0 flex flex-col items-center justify-center bg-white/70 text-center p-6 space-y-2">
                      <span className="text-4xl">üí•</span>
                      <p className="text-base font-semibold text-purple-600">¬°Ups! Lukis se ha cansado.</p>
                      <p className="text-sm text-gray-600">Puntuaci√≥n final: {score}</p>
                      <div className="flex space-x-2">
                        <button
                          onClick={resetGame}
                          className="px-4 py-2 rounded-full bg-purple-500 text-white text-sm font-semibold hover:bg-purple-600 transition"
                        >
                          Intentar de nuevo
                        </button>
                        <button
                          onClick={onExit}
                          className="px-4 py-2 rounded-full bg-gray-200 text-sm font-semibold hover:bg-gray-300 transition"
                        >
                          Salir
                        </button>
                      </div>
                    </div>
                  )}
                </div>
              </div>
            </div>
          );
        };

        const LaserChase = ({ onExit }) => {
          const AREA_SIZE = 320;
          const TARGET_SIZE = 32;
          const [targetPosition, setTargetPosition] = useState({ x: 0, y: 0 });
          const [score, setScore] = useState(0);
          const [timeLeft, setTimeLeft] = useState(30);
          const [isRunning, setIsRunning] = useState(false);
          const moveRef = useRef(null);
          const timerRef = useRef(null);

          const getRandomPosition = useCallback(() => ({
            x: Math.floor(Math.random() * (AREA_SIZE - TARGET_SIZE)),
            y: Math.floor(Math.random() * (AREA_SIZE - TARGET_SIZE))
          }), []);

          const stopGame = useCallback(() => {
            setIsRunning(false);
            if (moveRef.current) {
              clearInterval(moveRef.current);
              moveRef.current = null;
            }
            if (timerRef.current) {
              clearInterval(timerRef.current);
              timerRef.current = null;
            }
          }, []);

          const startGame = useCallback(() => {
            stopGame();
            setScore(0);
            setTimeLeft(30);
            setTargetPosition(getRandomPosition());
            setIsRunning(true);
          }, [getRandomPosition, stopGame]);

          useEffect(() => {
            if (!isRunning) {
              return;
            }

            moveRef.current = setInterval(() => {
              setTargetPosition(getRandomPosition());
            }, 650);

            timerRef.current = setInterval(() => {
              setTimeLeft((prev) => {
                if (prev <= 1) {
                  clearInterval(timerRef.current);
                  timerRef.current = null;
                  setIsRunning(false);
                  return 0;
                }
                return prev - 1;
              });
            }, 1000);

            return () => {
              if (moveRef.current) {
                clearInterval(moveRef.current);
                moveRef.current = null;
              }
              if (timerRef.current) {
                clearInterval(timerRef.current);
                timerRef.current = null;
              }
            };
          }, [isRunning, getRandomPosition]);

          const handleCatch = useCallback(() => {
            if (!isRunning) return;
            setScore((prev) => prev + 1);
            setTargetPosition(getRandomPosition());
          }, [getRandomPosition, isRunning]);

          useEffect(() => () => {
            if (moveRef.current) clearInterval(moveRef.current);
            if (timerRef.current) clearInterval(timerRef.current);
          }, []);

          const isFinished = !isRunning && timeLeft === 0;

          return (
            <div className="space-y-4">
              <div className="flex items-center justify-between text-sm text-gray-600">
                <div>
                  <span className="font-semibold text-pink-500">Puntos:</span> {score}
                </div>
                <div>
                  <span className="font-semibold text-purple-500">Tiempo:</span> {timeLeft}s
                </div>
              </div>
              <div
                className="relative mx-auto rounded-3xl border-4 border-purple-200 bg-gradient-to-br from-purple-100 via-pink-100 to-amber-100"
                style={{ width: AREA_SIZE, height: AREA_SIZE }}
              >
                {isRunning && (
                  <div
                    className="absolute rounded-full bg-gradient-to-br from-pink-500 via-red-500 to-yellow-400 shadow-lg cursor-pointer"
                    style={{
                      left: `${targetPosition.x}px`,
                      top: `${targetPosition.y}px`,
                      width: `${TARGET_SIZE}px`,
                      height: `${TARGET_SIZE}px`
                    }}
                    onClick={handleCatch}
                  >
                    <span className="sr-only">Atrapa el l√°ser</span>
                  </div>
                )}
                {!isRunning && !isFinished && (
                  <div className="absolute inset-0 flex flex-col items-center justify-center text-center p-6 space-y-3">
                    <span className="text-4xl">üî¥</span>
                    <p className="text-base font-semibold text-purple-600">Persigue el l√°ser</p>
                    <p className="text-sm text-gray-600">Toca el punto rojo tantas veces como puedas en 30 segundos.</p>
                    <div className="flex space-x-2">
                      <button
                        onClick={startGame}
                        className="px-4 py-2 rounded-full bg-purple-500 text-white text-sm font-semibold hover:bg-purple-600 transition"
                      >
                        ¬°Jugar!
                      </button>
                      <button
                        onClick={onExit}
                        className="px-4 py-2 rounded-full bg-gray-200 text-sm font-semibold hover:bg-gray-300 transition"
                      >
                        Salir
                      </button>
                    </div>
                  </div>
                )}
                {isFinished && (
                  <div className="absolute inset-0 flex flex-col items-center justify-center text-center p-6 space-y-3">
                    <span className="text-4xl">üéâ</span>
                    <p className="text-base font-semibold text-purple-600">¬°Tiempo!</p>
                    <p className="text-sm text-gray-600">Atrapes realizados: {score}</p>
                    <div className="flex space-x-2">
                      <button
                        onClick={startGame}
                        className="px-4 py-2 rounded-full bg-purple-500 text-white text-sm font-semibold hover:bg-purple-600 transition"
                      >
                        Reintentar
                      </button>
                      <button
                        onClick={onExit}
                        className="px-4 py-2 rounded-full bg-gray-200 text-sm font-semibold hover:bg-gray-300 transition"
                      >
                        Salir
                      </button>
                    </div>
                  </div>
                )}
              </div>
              {isRunning && (
                <div className="text-center">
                  <button
                    onClick={stopGame}
                    className="px-4 py-2 rounded-full bg-gray-200 text-sm font-semibold hover:bg-gray-300 transition"
                  >
                    Pausar
                  </button>
                </div>
              )}
            </div>
          );
        };

        const MemoryCats = ({ onExit }) => {
          const EMOJIS = ['üêü', 'üß∂', 'üêæ', 'üê¶', 'ü•õ', 'üê≠'];
          const shuffleArray = useCallback((array) => {
            const clone = [...array];
            for (let i = clone.length - 1; i > 0; i -= 1) {
              const j = Math.floor(Math.random() * (i + 1));
              [clone[i], clone[j]] = [clone[j], clone[i]];
            }
            return clone;
          }, []);

          const createDeck = useCallback(() => (
            shuffleArray(
              [...EMOJIS, ...EMOJIS].map((emoji, index) => ({
                id: `${emoji}-${index}`,
                emoji,
                matched: false
              }))
            )
          ), [EMOJIS, shuffleArray]);

          const [cards, setCards] = useState(() => createDeck());
          const [flipped, setFlipped] = useState([]);
          const [moves, setMoves] = useState(0);
          const [matchedPairs, setMatchedPairs] = useState(0);
          const [isChecking, setIsChecking] = useState(false);
          const checkTimeoutRef = useRef(null);

          const resetGame = useCallback(() => {
            if (checkTimeoutRef.current) {
              clearTimeout(checkTimeoutRef.current);
              checkTimeoutRef.current = null;
            }
            setCards(createDeck());
            setFlipped([]);
            setMoves(0);
            setMatchedPairs(0);
            setIsChecking(false);
          }, [createDeck]);

          const handleFlip = useCallback((index) => {
            if (isChecking) return;
            if (flipped.includes(index)) return;
            const card = cards[index];
            if (!card || card.matched) return;

            const newFlipped = [...flipped, index];
            setFlipped(newFlipped);

            if (newFlipped.length === 2) {
              setIsChecking(true);
              checkTimeoutRef.current = setTimeout(() => {
                const [firstIndex, secondIndex] = newFlipped;
                setCards((prevCards) => {
                  const firstCard = prevCards[firstIndex];
                  const secondCard = prevCards[secondIndex];
                  if (firstCard && secondCard && firstCard.emoji === secondCard.emoji && firstIndex !== secondIndex) {
                    setMatchedPairs((prev) => prev + 1);
                    return prevCards.map((cardItem, idx) =>
                      idx === firstIndex || idx === secondIndex
                        ? { ...cardItem, matched: true }
                        : cardItem
                    );
                  }
                  return prevCards;
                });
                setMoves((prev) => prev + 1);
                setFlipped([]);
                setIsChecking(false);
              }, 700);
            }
          }, [cards, flipped, isChecking]);

          useEffect(() => () => {
            if (checkTimeoutRef.current) {
              clearTimeout(checkTimeoutRef.current);
            }
          }, []);

          const allMatched = matchedPairs === EMOJIS.length;

          return (
            <div className="space-y-4">
              <div className="flex items-center justify-between text-sm text-gray-600">
                <span><span className="font-semibold text-purple-500">Movimientos:</span> {moves}</span>
                <button
                  onClick={onExit}
                  className="px-3 py-1.5 text-xs font-semibold rounded-full bg-gray-200 hover:bg-gray-300 transition"
                >
                  Salir
                </button>
              </div>
              <div className="grid grid-cols-3 gap-3">
                {cards.map((card, index) => {
                  const isFlipped = flipped.includes(index) || card.matched;
                  return (
                    <button
                      key={card.id}
                      onClick={() => handleFlip(index)}
                      className={`h-24 rounded-2xl flex items-center justify-center text-3xl transition transform ${
                        isFlipped ? 'bg-purple-200 rotate-y-0' : 'bg-purple-500 text-white'
                      } ${card.matched ? 'opacity-80' : 'hover:scale-105'}`}
                    >
                      {isFlipped ? card.emoji : '‚ùì'}
                    </button>
                  );
                })}
              </div>
              {allMatched ? (
                <div className="space-y-3 text-center">
                  <p className="text-lg font-semibold text-purple-600">¬°Perfecto! Encontraste todas las parejas.</p>
                  <p className="text-sm text-gray-600">¬øQuieres jugar otra vez?</p>
                  <div className="flex items-center justify-center space-x-2">
                    <button
                      onClick={resetGame}
                      className="px-4 py-2 rounded-full bg-purple-500 text-white text-sm font-semibold hover:bg-purple-600 transition"
                    >
                      Reiniciar
                    </button>
                    <button
                      onClick={onExit}
                      className="px-4 py-2 rounded-full bg-gray-200 text-sm font-semibold hover:bg-gray-300 transition"
                    >
                      Salir
                    </button>
                  </div>
                </div>
              ) : (
                <div className="flex items-center justify-between text-xs text-gray-500">
                  <span>Encuentra las {EMOJIS.length} parejas gatunas.</span>
                  <button
                    onClick={resetGame}
                    className="px-3 py-1 rounded-full bg-purple-100 text-purple-700 font-medium hover:bg-purple-200 transition"
                  >
                    Reiniciar
                  </button>
                </div>
              )}
            </div>
          );
        };

        const SOUND_LIBRARY = {
          meow: {
            files: ['meow-1.mp3', 'meow_QO6VsE6.mp3', 'the-end-meow-by-nekocat-just-3-second-1.mp3'],
            volume: 0.6
          },
          purr: {
            files: ['cat-purr.mp3', 'little-puff-purr.mp3', 'little-puff-purr-brr.mp3'],
            volume: 0.45
          }
        };

        const ACTION_SOUNDS = {
          feed: ['meow', 'purr'],
          play: ['meow'],
          sleep: ['purr']
        };

        const REMINDER_DELAY_MS = 1000 * 60 * 90;
        const REMINDER_MIN_DELAY_MS = 1000 * 30;
        const REMINDER_SYNC_TAG = 'catagotchi-reminder';

        const sendMessageToServiceWorker = async (message) => {
          if (typeof navigator === 'undefined' || !navigator.serviceWorker) {
            return;
          }
          try {
            const registration = await navigator.serviceWorker.ready;
            const targets = [
              navigator.serviceWorker.controller,
              registration?.active,
              registration?.waiting,
              registration?.installing
            ].filter(Boolean);
            targets.forEach((worker) => {
              try {
                worker.postMessage(message);
              } catch (error) {
                console.warn('No se pudo enviar el mensaje al service worker', error);
              }
            });
          } catch (error) {
            console.warn('No se pudo comunicar con el service worker', error);
          }
        };

        const clamp = (value, min, max) => Math.min(Math.max(value, min), max);

        const createSoundController = () => {
          if (typeof Audio === 'undefined') {
            return null;
          }

          const pools = Object.entries(SOUND_LIBRARY).reduce((acc, [key, definition]) => {
            const { files = [], volume = 0.5 } = definition || {};
            const entries = files.filter(Boolean).map(src => {
              const element = new Audio(src);
              element.preload = 'auto';
              element.volume = volume;
              return { src, instances: [element], volume };
            });
            if (entries.length > 0) {
              acc[key] = entries;
            }
            return acc;
          }, {});

          const getInstance = (entry) => {
            if (!entry) return null;
            const available = entry.instances.find(audio => audio.paused);
            if (available) {
              return available;
            }
            const clone = entry.instances[0]?.cloneNode(true) || new Audio(entry.src);
            clone.volume = entry.volume;
            clone.preload = 'auto';
            entry.instances.push(clone);
            return clone;
          };

          const playEffect = (effectKey) => {
            const entries = pools[effectKey];
            if (!entries || entries.length === 0) return;
            const entry = entries[Math.floor(Math.random() * entries.length)];
            const audio = getInstance(entry);
            if (!audio) return;
            audio.currentTime = 0;
            const playback = audio.play();
            if (playback && typeof playback.catch === 'function') {
              playback.catch(() => {});
            }
          };

          const playForAction = (actionKey) => {
            const effects = ACTION_SOUNDS[actionKey];
            if (Array.isArray(effects) && effects.length > 0) {
              effects.forEach(effect => playEffect(effect));
            } else {
              playEffect(actionKey);
            }
          };

          return {
            playEffect,
            playForAction
          };
        };

        const CatTamagotchi = () => {
          const [gameState, setGameState] = useState({
            happiness: 75,
            energy: 60,
            hunger: 40,
            mood: 'content',
            lastInteraction: Date.now()
          });

          const [cats, setCats] = useState([
            {
              name: 'Lukis',
              type: 'tuxedo',
              position: { x: 25, y: 60 },
              direction: 1,
              actionState: 'idle',
              tilt: 0,
              bobOffset: 0,
              eyeColor: 'bg-amber-300'
            },
            {
              name: 'Arwen',
              type: 'gris',
              position: { x: 50, y: 70 },
              direction: -1,
              actionState: 'idle',
              tilt: 0,
              bobOffset: 0,
              eyeColor: 'bg-slate-200'
            },
            {
              name: 'Iria',
              type: 'siamese',
              position: { x: 75, y: 65 },
              direction: 1,
              actionState: 'idle',
              tilt: 0,
              bobOffset: 0,
              eyeColor: 'bg-blue-500'
            }
          ]);

          const [isAnimating, setIsAnimating] = useState(false);
          const [currentAction, setCurrentAction] = useState('');
          const [isGameMenuOpen, setIsGameMenuOpen] = useState(false);
          const [activeGame, setActiveGame] = useState(null);
          const [isNightTime, setIsNightTime] = useState(false);
          const [canInstall, setCanInstall] = useState(false);
          const [installStatus, setInstallStatus] = useState('');
          const [isStandalone, setIsStandalone] = useState(false);
          const [isIosDevice, setIsIosDevice] = useState(false);
          const notificationsSupported = typeof window !== 'undefined' && typeof Notification === 'function';
          const [notificationsEnabled, setNotificationsEnabled] = useState(false);
          const [notificationStatus, setNotificationStatus] = useState('');
          const soundControllerRef = useRef(typeof window !== 'undefined' ? createSoundController() : null);
          const installPromptRef = useRef(null);
          const installStatusTimeoutRef = useRef(null);
          const notificationStatusTimeoutRef = useRef(null);
          const reminderTimeoutRef = useRef(null);
          const primaryCatName = cats[0]?.name || 'Tu gatito';

          const openGameMenu = useCallback(() => {
            setIsGameMenuOpen(true);
            setActiveGame(null);
            setGameState((prev) => ({
              ...prev,
              happiness: clamp(prev.happiness + 5, 0, 100),
              lastInteraction: Date.now()
            }));
          }, []);

          const handleCloseMenu = useCallback(() => {
            setIsGameMenuOpen(false);
            setActiveGame(null);
          }, []);

          const handleSelectGame = useCallback((gameId) => {
            setActiveGame(gameId);
            setIsGameMenuOpen(false);
            setGameState((prev) => ({
              ...prev,
              happiness: clamp(prev.happiness + 8, 0, 100),
              energy: clamp(prev.energy - 5, 0, 100),
              lastInteraction: Date.now()
            }));
          }, []);

          const closeGameExperience = useCallback(() => {
            setActiveGame(null);
            setIsGameMenuOpen(false);
            setGameState((prev) => ({
              ...prev,
              happiness: clamp(prev.happiness + 3, 0, 100),
              lastInteraction: Date.now()
            }));
          }, []);

          const showInstallStatus = useCallback((message) => {
            setInstallStatus(message);
            if (installStatusTimeoutRef.current) {
              clearTimeout(installStatusTimeoutRef.current);
            }
            installStatusTimeoutRef.current = setTimeout(() => {
              setInstallStatus('');
              installStatusTimeoutRef.current = null;
            }, 6000);
          }, []);

          const showNotificationStatus = useCallback((message) => {
            setNotificationStatus(message);
            if (notificationStatusTimeoutRef.current) {
              clearTimeout(notificationStatusTimeoutRef.current);
            }
            notificationStatusTimeoutRef.current = setTimeout(() => {
              setNotificationStatus('');
              notificationStatusTimeoutRef.current = null;
            }, 6000);
          }, []);

          const updateBackgroundReminderRegistration = useCallback(
            async (enabled, lastInteraction) => {
              if (!notificationsSupported || typeof navigator === 'undefined' || !navigator.serviceWorker) {
                return;
              }
              try {
                const registration = await navigator.serviceWorker.ready;
                const supportsPeriodicSync = 'periodicSync' in registration;
                const permissionGranted = Notification.permission === 'granted';
                const shouldEnable = Boolean(enabled && permissionGranted);

                if (supportsPeriodicSync) {
                  try {
                    const tags = await registration.periodicSync.getTags();
                    const alreadyRegistered = tags.includes(REMINDER_SYNC_TAG);
                    if (shouldEnable && !alreadyRegistered) {
                      await registration.periodicSync.register(REMINDER_SYNC_TAG, { minInterval: REMINDER_DELAY_MS });
                    } else if (!shouldEnable && alreadyRegistered) {
                      await registration.periodicSync.unregister(REMINDER_SYNC_TAG);
                    }
                  } catch (error) {
                    console.warn('No se pudo actualizar el registro de recordatorios en segundo plano', error);
                  }
                }

                const payload = {
                  enabled: shouldEnable,
                  name: primaryCatName,
                  url: typeof window !== 'undefined' ? window.location.href : './'
                };
                if (typeof lastInteraction === 'number' && Number.isFinite(lastInteraction)) {
                  payload.lastInteraction = lastInteraction;
                }

                await sendMessageToServiceWorker({ type: 'REMINDER_UPDATE', payload });
              } catch (error) {
                console.warn('No se pudo sincronizar la configuraci√≥n de recordatorios', error);
              }
            },
            [notificationsSupported, primaryCatName]
          );

          const showReminderNotification = useCallback(async () => {
            if (!notificationsEnabled || !notificationsSupported || Notification.permission !== 'granted') {
              return;
            }
            const catName = primaryCatName;
            const title = `¬°${catName} te echa de menos!`;
            const body = `${catName} quiere que vuelvas a jugar un ratito.`;
            const options = {
              body,
              icon: 'icons/caticon/icon.png',
              badge: 'icons/caticon/icon.png',
              tag: 'catagotchi-recordatorio',
              renotify: true,
              data: { url: typeof window !== 'undefined' ? window.location.href : './' }
            };
            try {
              if (typeof navigator !== 'undefined' && navigator.serviceWorker) {
                const registration = await navigator.serviceWorker.ready;
                if (registration?.showNotification) {
                  await registration.showNotification(title, options);
                } else {
                  new Notification(title, options);
                }
              } else {
                new Notification(title, options);
              }
            } catch (error) {
              console.error('No se pudo mostrar el recordatorio', error);
            } finally {
              const now = Date.now();
              setGameState((prev) => ({ ...prev, lastInteraction: now }));
              updateBackgroundReminderRegistration(true, now);
            }
          }, [notificationsEnabled, notificationsSupported, primaryCatName, updateBackgroundReminderRegistration]);

          const handleToggleNotifications = useCallback(async () => {
            if (!notificationsSupported) {
              showNotificationStatus('Tu dispositivo no admite notificaciones.');
              return;
            }
            if (notificationsEnabled) {
              setNotificationsEnabled(false);
              showNotificationStatus('Recordatorios en pausa.');
              await updateBackgroundReminderRegistration(false, Date.now());
              return;
            }
            let permission = Notification.permission;
            if (permission === 'default') {
              try {
                permission = await Notification.requestPermission();
              } catch (error) {
                permission = Notification.permission;
              }
            }
            if (permission !== 'granted') {
              setNotificationsEnabled(false);
              showNotificationStatus('Activa las notificaciones desde los ajustes del navegador.');
              await updateBackgroundReminderRegistration(false, Date.now());
              return;
            }
            const now = Date.now();
            setNotificationsEnabled(true);
            setGameState((prev) => ({ ...prev, lastInteraction: now }));
            showNotificationStatus(`${primaryCatName} te avisar√° cuando necesite mimos.`);
            await updateBackgroundReminderRegistration(true, now);
          }, [notificationsSupported, notificationsEnabled, showNotificationStatus, updateBackgroundReminderRegistration, primaryCatName]);

          const playActionSound = useCallback((actionKey) => {
            const controller = soundControllerRef.current;
            if (!controller) return;
            controller.playForAction(actionKey);
          }, []);

          useEffect(() => {
            if (typeof window === 'undefined') {
              return undefined;
            }
            setIsIosDevice(/iphone|ipad|ipod/i.test(window.navigator.userAgent || ''));
            return () => {
              if (installStatusTimeoutRef.current) {
                clearTimeout(installStatusTimeoutRef.current);
              }
              if (notificationStatusTimeoutRef.current) {
                clearTimeout(notificationStatusTimeoutRef.current);
              }
              if (reminderTimeoutRef.current) {
                clearTimeout(reminderTimeoutRef.current);
              }
            };
          }, []);

          useEffect(() => {
            if (typeof navigator !== 'undefined' && 'serviceWorker' in navigator) {
              navigator.serviceWorker.register('./service-worker.js').catch(() => {});
            }
          }, []);

          useEffect(() => {
            if (!notificationsSupported) {
              return;
            }
            if (notificationsEnabled && Notification.permission !== 'granted') {
              setNotificationsEnabled(false);
              updateBackgroundReminderRegistration(false, Date.now());
            }
          }, [notificationsEnabled, notificationsSupported, updateBackgroundReminderRegistration]);

          useEffect(() => {
            if (typeof window === 'undefined' || !notificationsSupported) {
              return;
            }
            try {
              const stored = window.localStorage.getItem('catagotchi-reminders');
              if (stored === 'on' && Notification.permission === 'granted') {
                setNotificationsEnabled(true);
              }
            } catch (error) {
              console.warn('No se pudo restaurar la configuraci√≥n de recordatorios', error);
            }
          }, [notificationsSupported]);

          useEffect(() => {
            if (typeof window === 'undefined') {
              return;
            }
            try {
              window.localStorage.setItem('catagotchi-reminders', notificationsEnabled ? 'on' : 'off');
            } catch (error) {
              console.warn('No se pudo guardar la configuraci√≥n de recordatorios', error);
            }
          }, [notificationsEnabled]);

          useEffect(() => {
            if (!notificationsEnabled || !notificationsSupported || Notification.permission !== 'granted') {
              if (reminderTimeoutRef.current) {
                clearTimeout(reminderTimeoutRef.current);
                reminderTimeoutRef.current = null;
              }
              return;
            }
            const now = Date.now();
            const lastInteraction = gameState.lastInteraction || now;
            const elapsed = now - lastInteraction;
            const delay = Math.max(REMINDER_MIN_DELAY_MS, REMINDER_DELAY_MS - elapsed);
            if (reminderTimeoutRef.current) {
              clearTimeout(reminderTimeoutRef.current);
            }
            reminderTimeoutRef.current = setTimeout(() => {
              reminderTimeoutRef.current = null;
              showReminderNotification();
            }, delay);

            return () => {
              if (reminderTimeoutRef.current) {
                clearTimeout(reminderTimeoutRef.current);
                reminderTimeoutRef.current = null;
              }
            };
          }, [notificationsEnabled, notificationsSupported, gameState.lastInteraction, showReminderNotification]);

          useEffect(() => {
            updateBackgroundReminderRegistration(notificationsEnabled, gameState.lastInteraction);
          }, [notificationsEnabled, gameState.lastInteraction, updateBackgroundReminderRegistration]);

          useEffect(() => {
            if (typeof window === 'undefined') {
              return undefined;
            }
            const updateTimeOfDay = () => {
              const hour = new Date().getHours();
              setIsNightTime(hour < 6 || hour >= 20);
            };
            updateTimeOfDay();
            const timeInterval = setInterval(updateTimeOfDay, 60000);
            return () => clearInterval(timeInterval);
          }, []);

          useEffect(() => {
            if (typeof window === 'undefined') {
              return undefined;
            }
            const handleBeforeInstallPrompt = (event) => {
              event.preventDefault();
              installPromptRef.current = event;
              setCanInstall(true);
            };

            const handleAppInstalled = () => {
              installPromptRef.current = null;
              setCanInstall(false);
              setIsStandalone(true);
              showInstallStatus('Catagotchi est√° en tu pantalla de inicio üêæ');
            };

            window.addEventListener('beforeinstallprompt', handleBeforeInstallPrompt);
            window.addEventListener('appinstalled', handleAppInstalled);

            return () => {
              window.removeEventListener('beforeinstallprompt', handleBeforeInstallPrompt);
              window.removeEventListener('appinstalled', handleAppInstalled);
            };
          }, [showInstallStatus]);

          useEffect(() => {
            if (typeof window === 'undefined' || typeof window.matchMedia !== 'function') {
              return undefined;
            }
            const mediaQuery = window.matchMedia('(display-mode: standalone)');

            const updateStandalone = () => {
              const navigatorStandalone =
                typeof window.navigator !== 'undefined' && 'standalone' in window.navigator
                  ? window.navigator.standalone
                  : false;
              const standalone = mediaQuery.matches || Boolean(navigatorStandalone);
              setIsStandalone(standalone);
            };

            updateStandalone();

            if (typeof mediaQuery.addEventListener === 'function') {
              mediaQuery.addEventListener('change', updateStandalone);
            } else if (typeof mediaQuery.addListener === 'function') {
              mediaQuery.addListener(updateStandalone);
            }

            return () => {
              if (typeof mediaQuery.removeEventListener === 'function') {
                mediaQuery.removeEventListener('change', updateStandalone);
              } else if (typeof mediaQuery.removeListener === 'function') {
                mediaQuery.removeListener(updateStandalone);
              }
            };
          }, []);

          useEffect(() => {
            const moveInterval = setInterval(() => {
              if (gameState.mood === 'tired' || isAnimating) return;
              setCats(prevCats =>
                prevCats.map(cat => {
                  const step = Math.random() * 4 + 2;
                  let newX = cat.position.x + cat.direction * step;
                  let newDirection = cat.direction;
                  if (newX <= 12) {
                    newX = 12;
                    newDirection = 1;
                  } else if (newX >= 88) {
                    newX = 88;
                    newDirection = -1;
                  }
                  if (Math.random() < 0.25) {
                    newDirection *= -1;
                  }
                  const newY = clamp(cat.position.y + (Math.random() - 0.5) * 4, 55, 78);
                  const tilt = clamp((Math.random() - 0.5) * 12, -8, 8);
                  const bobOffset = clamp((Math.random() - 0.5) * 8, -4, 4);
                  return {
                    ...cat,
                    position: { x: newX, y: newY },
                    direction: newDirection,
                    tilt,
                    bobOffset
                  };
                })
              );
            }, 1400);
            return () => clearInterval(moveInterval);
          }, [gameState.mood, isAnimating]);

          useEffect(() => {
            const interval = setInterval(() => {
              setGameState(prevState => {
                const newHunger = Math.max(0, prevState.hunger - 5);
                const newEnergy = Math.max(0, prevState.energy - 5);
                const newHappiness = Math.max(0, prevState.happiness - 5);
                let mood = 'content';
                if (newHappiness > 70 && newEnergy > 70 && newHunger > 70) mood = 'happy';
                else if (newHappiness > 50 && newEnergy > 50 && newHunger > 50) mood = 'content';
                else if (newHunger < 30) mood = 'hungry';
                else if (newEnergy < 30) mood = 'tired';
                else if (newHappiness < 30) mood = 'sad';
                return {
                  ...prevState,
                  hunger: newHunger,
                  energy: newEnergy,
                  happiness: newHappiness,
                  mood
                };
              });
            }, 3000);
            return () => clearInterval(interval);
          }, []);

          const handleAction = (action) => {
            if (isAnimating) return;
            setIsAnimating(true);
            setCurrentAction(action);
            playActionSound(action);
            setCats(prevCats =>
              prevCats.map(cat => ({
                ...cat,
                actionState: action
              }))
            );
            setTimeout(() => {
              setGameState(prevState => {
                let newState = { ...prevState, lastInteraction: Date.now() };
                switch (action) {
                  case 'feed':
                    newState.hunger = Math.min(100, prevState.hunger + 30);
                    newState.happiness = Math.min(100, prevState.happiness + 15);
                    break;
                  case 'play':
                    newState.energy = Math.max(20, prevState.energy - 15);
                    newState.happiness = Math.min(100, prevState.happiness + 25);
                    newState.hunger = Math.max(0, prevState.hunger - 10);
                    break;
                  case 'sleep':
                    newState.energy = Math.min(100, prevState.energy + 40);
                    newState.hunger = Math.max(0, prevState.hunger - 5);
                    break;
                  default:
                    break;
                }
                if (newState.happiness > 70 && newState.energy > 70 && newState.hunger > 70) newState.mood = 'happy';
                else if (newState.happiness > 50 && newState.energy > 50 && newState.hunger > 50) newState.mood = 'content';
                else if (newState.hunger < 30) newState.mood = 'hungry';
                else if (newState.energy < 30) newState.mood = 'tired';
                else if (newState.happiness < 30) newState.mood = 'sad';
                else newState.mood = 'content';
                return newState;
              });
              setCats(prevCats => 
                prevCats.map(cat => ({
                  ...cat,
                  actionState: 'idle'
                }))
              );
              setIsAnimating(false);
              setCurrentAction('');
            }, 2500);
          };

          const handleInstallClick = useCallback(async () => {
            if (installPromptRef.current) {
              try {
                installPromptRef.current.prompt();
                const choice = await installPromptRef.current.userChoice;
                if (choice?.outcome === 'accepted') {
                  showInstallStatus('¬°Listo! Busca Catagotchi en tu pantalla de inicio.');
                } else {
                  showInstallStatus('Puedes a√±adir Catagotchi m√°s tarde desde el men√∫ de tu navegador.');
                }
              } catch (error) {
                showInstallStatus('No se pudo completar la instalaci√≥n. Int√©ntalo de nuevo m√°s tarde.');
              } finally {
                installPromptRef.current = null;
                setCanInstall(false);
              }
              return;
            }

            if (isIosDevice) {
              showInstallStatus('Pulsa el bot√≥n Compartir y elige "A√±adir a pantalla de inicio".');
            } else {
              showInstallStatus('Busca "A√±adir a pantalla de inicio" en el men√∫ de tu navegador.');
            }
          }, [isIosDevice, showInstallStatus]);

          const shouldShowInstallButton = !isStandalone && (canInstall || isIosDevice);

          const getStatColor = (value) => {
            if (value > 70) return 'bg-green-500';
            if (value > 40) return 'bg-yellow-500';
            return 'bg-red-500';
          };

          const getMoodEmoji = (mood) => {
            switch (mood) {
              case 'happy': return 'üò∏';
              case 'content': return 'üò∫';
              case 'hungry': return 'üôÄ';
              case 'tired': return 'üò¥';
              case 'sad': return 'üòø';
              default: return 'üò∏';
            }
          };

          const getCatDisplay = (cat) => {
            const transformParts = ['translate(-50%, -50%)'];
            if (cat.direction < 0) transformParts.push('scaleX(-1)');
            if (cat.bobOffset) transformParts.push(`translateY(${cat.bobOffset}px)`);
            if (cat.tilt) transformParts.push(`rotate(${cat.tilt}deg)`);
            const transform = transformParts.join(' ');
            let extraElements = null;
            const avgStats = (gameState.happiness + gameState.energy + gameState.hunger) / 3;

            switch (cat.actionState) {
              case 'feed':
                extraElements = (
                  <div className="absolute -top-8 left-1/2 transform -translate-x-1/2">
                    <div className="text-lg animate-bounce">ü•õ</div>
                  </div>
                );
                break;
              case 'play':
                extraElements = (
                  <div className="absolute -top-8 left-1/2 transform -translate-x-1/2">
                    <div className="text-lg animate-pulse">üê≠</div>
                  </div>
                );
                break;
              case 'sleep':
                extraElements = (
                  <div className="absolute -top-6 left-1/2 transform -translate-x-1/2">
                    <div className="text-lg animate-pulse">üí§</div>
                  </div>
                );
                break;
              default:
                if (avgStats < 60) {
                  let angerEmoji = null;
                  if (avgStats < 20) angerEmoji = 'üò°';
                  else if (avgStats < 40) angerEmoji = 'üò†';
                  else angerEmoji = 'üò§';
                  extraElements = (
                    <div className="absolute -top-6 left-1/2 transform -translate-x-1/2">
                      <div className="text-lg animate-bounce">{angerEmoji}</div>
                    </div>
                  );
                }
                break;
            }

            const CatBody = ({ type, eyeColorClass }) => {
              const colors = {
                tuxedo: { body: 'bg-gray-900', chest: 'bg-white', ears: 'bg-gray-900' },
                gris: { body: 'bg-gray-400', chest: 'bg-white', ears: 'bg-gray-400' },
                siamese: { body: 'bg-yellow-100', face: 'bg-amber-800', ears: 'bg-amber-800' }
              }[type];

              const isSleeping = cat.actionState === 'sleep';
              const resolvedEyeClass =
                eyeColorClass ||
                (type === 'siamese' ? 'bg-blue-500' : type === 'gris' ? 'bg-blue-400' : 'bg-green-400');

              return (
                <div className="relative w-16 h-16">
                  <div className={`absolute bottom-0 left-2 w-12 h-12 ${colors.body} rounded-full`}></div>
                  {(type === 'tuxedo' || type === 'gris') && (
                    <div className={`absolute bottom-1 left-4 w-8 h-9 ${colors.chest} rounded-full`}></div>
                  )}
                  <div className={`absolute top-0 left-2 w-12 h-12 ${colors.body} rounded-full`}></div>
                  {type === 'siamese' ? (
                    <div className={`absolute top-1 left-3 w-10 h-9 ${colors.face} rounded-full`}></div>
                  ) : (
                    <div>
                      <div className="absolute top-1 left-5 w-6 h-8 bg-white rounded-full"></div>
                      <div className="absolute top-6 left-7 w-2 h-3 bg-white transform rotate-45 rounded-sm"></div>
                    </div>
                  )}
                  <div className={`absolute -top-1 left-3 w-4 h-5 ${colors.ears} rounded-full transform -rotate-12`}></div>
                  <div className={`absolute -top-1 right-3 w-4 h-5 ${colors.ears} rounded-full transform rotate-12`}></div>
                  <div className="absolute top-0 left-4 w-2 h-3 bg-pink-300 rounded-full transform -rotate-12"></div>
                  <div className="absolute top-0 right-4 w-2 h-3 bg-pink-300 rounded-full transform rotate-12"></div>
                  {isSleeping ? (
                    <>
                      <div className="absolute top-4 left-4 w-2 h-1 bg-gray-800 rounded-full"></div>
                      <div className="absolute top-4 right-4 w-2 h-1 bg-gray-800 rounded-full"></div>
                    </>
                  ) : (
                    <>
                      <div className={`absolute top-4 left-4 w-2 h-2 ${resolvedEyeClass} rounded-full`}></div>
                      <div className={`absolute top-4 right-4 w-2 h-2 ${resolvedEyeClass} rounded-full`}></div>
                    </>
                  )}
                  <div className="absolute top-5 left-1/2 transform -translate-x-1/2 w-1 h-1 bg-pink-400 rounded-full"></div>
                  <div className={`absolute -right-1 bottom-3 w-3 h-8 ${colors.body} rounded-full transform rotate-45`}></div>
                  <div className={`absolute bottom-0 left-3 w-1.5 h-4 ${type === 'siamese' ? 'bg-amber-800' : colors.body} rounded-full`}></div>
                  <div className={`absolute bottom-0 right-3 w-1.5 h-4 ${type === 'siamese' ? 'bg-amber-800' : colors.body} rounded-full`}></div>
                </div>
              );
            };

            return (
              <div
                className="absolute transition-all duration-1000"
                style={{ left: `${cat.position.x}%`, top: `${cat.position.y}%`, transform }}
              >
                <CatBody type={cat.type} eyeColorClass={cat.eyeColor} />
                {extraElements}
              </div>
            );
          };

          const activeGameDefinition = activeGame
            ? GAME_DEFINITIONS.find((game) => game.id === activeGame)
            : null;

          return (
            <div className="min-h-screen bg-gradient-to-br from-purple-400 via-pink-300 to-yellow-300 p-4">
              <div className="max-w-md mx-auto bg-white rounded-3xl shadow-2xl overflow-hidden">
                <div className="bg-gradient-to-r from-purple-500 to-pink-500 p-4 text-white text-center">
                  <h1 className="text-2xl font-bold">üê± Los Tres Gatitos üê±</h1>
                  <p className="text-sm opacity-90">Lukis, Arwen e Iria</p>
                </div>

                <div className={`relative h-64 ${isNightTime ? 'bg-gradient-to-b from-indigo-900 to-purple-900' : 'bg-gradient-to-b from-blue-100 to-green-200'} overflow-hidden transition-all duration-1000`}>
                  <div className="absolute bottom-0 w-full h-12 bg-amber-200"></div>
                  <div className="absolute left-0 top-0 w-2 h-full bg-amber-300"></div>
                  <div className="absolute right-0 top-0 w-2 h-full bg-amber-300"></div>
                  <div className="absolute top-0 w-full h-2 bg-amber-300"></div>

                  <div className="absolute top-4 right-4 w-24 h-20 bg-sky-200 border-4 border-amber-600 rounded">
                    <div className={`absolute inset-1 ${isNightTime ? 'bg-indigo-900' : 'bg-sky-100'} transition-all duration-1000`}>
                      <div className="w-full h-0.5 bg-amber-600 absolute top-1/2 transform -translate-y-1/2"></div>
                      <div className="h-full w-0.5 bg-amber-600 absolute left-1/2 transform -translate-x-1/2"></div>
                      {isNightTime ? (
                        <>
                          <div className="absolute top-2 right-2 w-6 h-6 bg-yellow-100 rounded-full shadow-lg"></div>
                          <div className="absolute top-1 left-2 text-yellow-200 text-xs">‚ú¶</div>
                        </>
                      ) : (
                        <>
                          <div className="absolute top-2 left-2 w-8 h-8 bg-yellow-400 rounded-full animate-pulse"></div>
                          <div className="absolute top-1 right-1 w-4 h-2 bg-white rounded-full opacity-70"></div>
                        </>
                      )}
                    </div>
                    <div className="absolute -top-1 -left-2 w-5 h-20 bg-pink-300 rounded-r-lg"></div>
                    <div className="absolute -top-1 -right-2 w-5 h-20 bg-pink-300 rounded-l-lg"></div>
                  </div>

                  <div className="absolute bottom-12 left-4 w-12 h-6 bg-red-400 rounded-full border-2 border-red-500"></div>
                  <div className="absolute bottom-12 right-8 w-6 h-3 bg-gray-300 rounded-full border border-gray-400"></div>
                  <div className="absolute bottom-12 right-16 w-6 h-3 bg-gray-300 rounded-full border border-gray-400"></div>
                  <div className="absolute bottom-12 right-24 w-6 h-3 bg-gray-300 rounded-full border border-gray-400"></div>
                  <div className="absolute bottom-12 left-1/4 w-36 h-10 bg-purple-300 rounded-lg opacity-60"></div>

                  {cats.map((cat, index) => (
                    <div key={index}>{getCatDisplay(cat)}</div>
                  ))}
                </div>

                <div className="p-4 text-center bg-gray-50">
                  <div className="flex justify-center items-center space-x-2 mb-2">
                    <span className="text-lg">{getMoodEmoji(gameState.mood)}</span>
                    <span className="text-sm text-gray-600 capitalize">
                      Estado: {gameState.mood === 'happy' ? 'Felices' : 
                             gameState.mood === 'content' ? 'Tranquilos' :
                             gameState.mood === 'hungry' ? 'Hambrientos' :
                             gameState.mood === 'tired' ? 'Cansados' :
                             gameState.mood === 'sad' ? 'Tristes' : 'Juguetones'}
                    </span>
                  </div>
                  <div className="flex justify-center items-center space-x-2">
                    <span className="text-base" role="img" aria-hidden="true">
                      {isNightTime ? 'üåô' : '‚òÄÔ∏è'}
                    </span>
                    <span className="text-xs text-gray-500">
                      {isNightTime ? 'Hora de dormir' : 'D√≠a activo'}
                    </span>
                  </div>
                </div>

                <div className="px-6 pb-6 space-y-3">
                  <div className="flex items-center space-x-3">
                    <span className="text-red-500 text-xl" role="img" aria-hidden="true">‚ù§Ô∏è</span>
                    <div className="flex-1">
                      <div className="flex justify-between text-sm mb-1">
                        <span className="font-medium">Felicidad</span>
                        <span>{Math.round(gameState.happiness)}%</span>
                      </div>
                      <div className="w-full bg-gray-200 rounded-full h-2">
                        <div
                          className={`h-2 rounded-full transition-all duration-500 ${getStatColor(gameState.happiness)}`}
                          style={{ width: `${gameState.happiness}%` }}
                        ></div>
                      </div>
                    </div>
                  </div>

                  <div className="flex items-center space-x-3">
                    <span className="text-green-500 text-xl" role="img" aria-hidden="true">üîã</span>
                    <div className="flex-1">
                      <div className="flex justify-between text-sm mb-1">
                        <span className="font-medium">Energ√≠a</span>
                        <span>{Math.round(gameState.energy)}%</span>
                      </div>
                      <div className="w-full bg-gray-200 rounded-full h-2">
                        <div
                          className={`h-2 rounded-full transition-all duration-500 ${getStatColor(gameState.energy)}`}
                          style={{ width: `${gameState.energy}%` }}
                        ></div>
                      </div>
                    </div>
                  </div>

                  <div className="flex items-center space-x-3">
                    <span className="text-yellow-600 text-xl" role="img" aria-hidden="true">üçó</span>
                    <div className="flex-1">
                      <div className="flex justify-between text-sm mb-1">
                        <span className="font-medium">Hambre</span>
                        <span>{Math.round(gameState.hunger)}%</span>
                      </div>
                      <div className="w-full bg-gray-200 rounded-full h-2">
                        <div
                          className={`h-2 rounded-full transition-all duration-500 ${
                            gameState.hunger < 30 ? 'bg-red-500' :
                            gameState.hunger < 60 ? 'bg-yellow-500' : 'bg-green-500'
                          }`}
                          style={{ width: `${gameState.hunger}%` }}
                        ></div>
                      </div>
                    </div>
                  </div>
                </div>

                <div className="p-6 bg-gray-50 flex flex-wrap justify-center gap-4">
                  <button
                    onClick={() => handleAction('feed')}
                    disabled={isAnimating}
                    className="flex flex-col items-center space-y-2 px-4 py-3 bg-green-500 hover:bg-green-600 disabled:bg-gray-400 text-white rounded-2xl transition-all duration-300 transform hover:scale-105 disabled:scale-100"
                  >
                    <span className="text-2xl" role="img" aria-hidden="true">üç≤</span>
                    <span className="text-xs font-medium">Comer</span>
                  </button>

                  <button
                    onClick={() => handleAction('play')}
                    disabled={isAnimating}
                    className="flex flex-col items-center space-y-2 px-4 py-3 bg-blue-500 hover:bg-blue-600 disabled:bg-gray-400 text-white rounded-2xl transition-all duration-300 transform hover:scale-105 disabled:scale-100"
                  >
                    <span className="text-2xl" role="img" aria-hidden="true">üß∂</span>
                    <span className="text-xs font-medium">Jugar</span>
                  </button>

                  <button
                    onClick={() => handleAction('sleep')}
                    disabled={isAnimating}
                    className="flex flex-col items-center space-y-2 px-4 py-3 bg-purple-500 hover:bg-purple-600 disabled:bg-gray-400 text-white rounded-2xl transition-all duration-300 transform hover:scale-105 disabled:scale-100"
                  >
                    <span className="text-2xl" role="img" aria-hidden="true">üåô</span>
                    <span className="text-xs font-medium">Dormir</span>
                  </button>
                  <button
                    onClick={() => {
                      playActionSound('play');
                      openGameMenu();
                    }}
                    className="flex flex-col items-center space-y-2 px-4 py-3 bg-amber-500 hover:bg-amber-600 text-white rounded-2xl transition-all duration-300 transform hover:scale-105"
                  >
                    <span className="text-2xl" role="img" aria-hidden="true">üéÆ</span>
                    <span className="text-xs font-medium">Juegos</span>
                  </button>
                </div>

                {notificationsSupported && (
                  <div className="px-6 pb-4">
                    <button
                      onClick={handleToggleNotifications}
                      className={`w-full flex items-center justify-center space-x-2 px-4 py-3 rounded-2xl transition-all duration-300 text-white ${
                        notificationsEnabled ? 'bg-amber-500 hover:bg-amber-600' : 'bg-amber-400 hover:bg-amber-500'
                      }`}
                    >
                      <span className="text-xl" role="img" aria-hidden="true">{notificationsEnabled ? 'üîï' : 'üîî'}</span>
                      <span className="text-sm font-semibold">
                        {notificationsEnabled ? 'Pausar recordatorios' : 'Activar recordatorios'}
                      </span>
                    </button>
                    {!notificationsEnabled && !isStandalone && Notification?.permission !== 'granted' && (
                      <p className="mt-3 text-xs text-center text-gray-600">
                        A√±ade Catagotchi a tu pantalla de inicio para que los recordatorios funcionen mejor.
                      </p>
                    )}
                    {notificationStatus && (
                      <div className="mt-3 bg-amber-50 border border-amber-200 text-amber-700 text-sm rounded-2xl px-4 py-3 text-center">
                        {notificationStatus}
                      </div>
                    )}
                  </div>
                )}

                {installStatus && (
                  <div className="px-6 pb-4">
                    <div className="bg-pink-50 border border-pink-200 text-pink-700 text-sm rounded-2xl px-4 py-3 text-center">
                      {installStatus}
                    </div>
                  </div>
                )}

                {shouldShowInstallButton && (
                  <div className="px-6 pb-6">
                    <button
                      onClick={handleInstallClick}
                      className="w-full flex items-center justify-center space-x-2 px-4 py-3 bg-pink-500 hover:bg-pink-600 text-white rounded-2xl transition-all duration-300"
                    >
                      <span className="text-xl" role="img" aria-hidden="true">üì≤</span>
                      <span className="text-sm font-semibold">Guardar en pantalla de inicio</span>
                    </button>
                    {isIosDevice && !canInstall && (
                      <p className="mt-3 text-xs text-center text-gray-600">
                        En iPhone o iPad abre el men√∫ de compartir y toca ¬´A√±adir a pantalla de inicio¬ª.
                      </p>
                    )}
                  </div>
                )}

                {currentAction && (
                  <div className="px-6 pb-6">
                    <div className="bg-purple-100 text-purple-700 rounded-2xl p-3 text-center text-sm font-medium animate-pulse">
                      Ejecutando acci√≥n: {currentAction === 'feed' ? 'Comer' : currentAction === 'play' ? 'Jugar' : 'Dormir'}...
                    </div>
                  </div>
                )}
              </div>
              {isGameMenuOpen && (
                <GameMenu onSelect={handleSelectGame} onClose={handleCloseMenu} />
              )}
              {activeGame && activeGameDefinition && (
                <GameOverlay title={activeGameDefinition.title} onClose={closeGameExperience}>
                  {activeGame === 'flappy-lukis' && <FlappyLukis onExit={closeGameExperience} />}
                  {activeGame === 'laser-chase' && <LaserChase onExit={closeGameExperience} />}
                  {activeGame === 'memory-cats' && <MemoryCats onExit={closeGameExperience} />}
                </GameOverlay>
              )}
          </div>
        );
        };

        ReactDOM.createRoot(document.getElementById('root')).render(<CatTamagotchi />);
    </script>
</body>
</html>
