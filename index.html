<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Catagotchi</title>
    <meta name="theme-color" content="#ff85c5">
    <link rel="manifest" href="manifest.webmanifest">
    <link rel="icon" type="image/png" href="icons/caticon/icon.png">
    <link rel="apple-touch-icon" href="icons/caticon/icon.png">
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        const GAME_DEFINITIONS = [
          {
            id: 'flappy-lukis',
            title: 'Flappy Lukis',
            emoji: 'üêæ',
            description: 'Ayuda a Lukis a volar entre las nubes sin chocarse.'
          },
          {
            id: 'lukis-sky-jump',
            title: 'Lukis Aventurero',
            emoji: 'ü™ú',
            description: 'Salta plataformas hacia el cielo como en Pou y llega lo m√°s alto posible.'
          }
        ];

        const GameOverlay = ({ title, onClose, children }) => (
          <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-60 px-4">
            <div className="w-full max-w-md bg-white rounded-3xl shadow-2xl overflow-hidden">
              <div className="flex items-center justify-between px-5 py-4 bg-gradient-to-r from-purple-500 to-pink-500 text-white">
                <h2 className="text-lg font-semibold">{title}</h2>
                <button
                  onClick={onClose}
                  className="text-white/90 hover:text-white transition"
                  aria-label="Cerrar"
                >
                  ‚úñÔ∏è
                </button>
              </div>
              <div className="p-5 space-y-4 max-h-[70vh] overflow-y-auto">{children}</div>
            </div>
          </div>
        );

        const LukisFace = ({ size = 48, className = '', style = {} }) => {
          const earWidth = size * 0.32;
          const earHeight = size * 0.42;
          const innerEarWidth = size * 0.18;
          const innerEarHeight = size * 0.26;
          const eyeSize = size * 0.18;
          const pupilSize = size * 0.08;
          const whiskerLength = size * 0.32;
          return (
            <div
              className={`relative ${className}`}
              style={{ width: size, height: size, ...style }}
              aria-hidden="true"
            >
              <div className="absolute inset-0 rounded-full" style={{ background: '#111827' }}></div>
              <div
                className="absolute"
                style={{
                  left: size * 0.18,
                  bottom: size * 0.08,
                  width: size * 0.64,
                  height: size * 0.58,
                  background: '#ffffff',
                  borderRadius: '48%'
                }}
              ></div>
              <div
                className="absolute"
                style={{
                  left: size * 0.05,
                  top: size * -0.04,
                  width: earWidth,
                  height: earHeight,
                  background: '#111827',
                  borderRadius: '45% 45% 10% 10%',
                  transform: 'rotate(-18deg)'
                }}
              ></div>
              <div
                className="absolute"
                style={{
                  right: size * 0.05,
                  top: size * -0.04,
                  width: earWidth,
                  height: earHeight,
                  background: '#111827',
                  borderRadius: '45% 45% 10% 10%',
                  transform: 'rotate(18deg)'
                }}
              ></div>
              <div
                className="absolute"
                style={{
                  left: size * 0.12,
                  top: size * 0.02,
                  width: innerEarWidth,
                  height: innerEarHeight,
                  background: '#f9a8d4',
                  borderRadius: '45% 45% 10% 10%',
                  transform: 'rotate(-18deg)'
                }}
              ></div>
              <div
                className="absolute"
                style={{
                  right: size * 0.12,
                  top: size * 0.02,
                  width: innerEarWidth,
                  height: innerEarHeight,
                  background: '#f9a8d4',
                  borderRadius: '45% 45% 10% 10%',
                  transform: 'rotate(18deg)'
                }}
              ></div>
              <div
                className="absolute"
                style={{
                  left: size * 0.22,
                  top: size * 0.38,
                  width: eyeSize,
                  height: eyeSize,
                  background: '#bef264',
                  borderRadius: '50%'
                }}
              >
                <div
                  className="absolute"
                  style={{
                    left: '50%',
                    top: '40%',
                    width: pupilSize,
                    height: pupilSize,
                    background: '#0f172a',
                    borderRadius: '50%',
                    transform: 'translate(-50%, -50%)'
                  }}
                ></div>
                <div
                  className="absolute"
                  style={{
                    left: '30%',
                    top: '25%',
                    width: pupilSize * 0.4,
                    height: pupilSize * 0.4,
                    background: '#f8fafc',
                    borderRadius: '50%'
                  }}
                ></div>
              </div>
              <div
                className="absolute"
                style={{
                  right: size * 0.22,
                  top: size * 0.38,
                  width: eyeSize,
                  height: eyeSize,
                  background: '#bef264',
                  borderRadius: '50%'
                }}
              >
                <div
                  className="absolute"
                  style={{
                    left: '50%',
                    top: '40%',
                    width: pupilSize,
                    height: pupilSize,
                    background: '#0f172a',
                    borderRadius: '50%',
                    transform: 'translate(-50%, -50%)'
                  }}
                ></div>
                <div
                  className="absolute"
                  style={{
                    left: '30%',
                    top: '25%',
                    width: pupilSize * 0.4,
                    height: pupilSize * 0.4,
                    background: '#f8fafc',
                    borderRadius: '50%'
                  }}
                ></div>
              </div>
              <div
                className="absolute"
                style={{
                  left: '50%',
                  top: size * 0.6,
                  width: size * 0.18,
                  height: size * 0.12,
                  background: '#f472b6',
                  borderRadius: '45%',
                  transform: 'translateX(-50%)'
                }}
              ></div>
              <div
                className="absolute"
                style={{
                  left: '50%',
                  top: size * 0.7,
                  width: size * 0.24,
                  height: size * 0.16,
                  borderBottom: `${size * 0.06}px solid #111827`,
                  borderLeft: `${size * 0.04}px solid transparent`,
                  borderRight: `${size * 0.04}px solid transparent`,
                  transform: 'translateX(-50%) rotate(180deg)'
                }}
              ></div>
              <div
                className="absolute"
                style={{
                  left: size * 0.08,
                  top: size * 0.62,
                  width: whiskerLength,
                  height: size * 0.02,
                  background: '#111827',
                  borderRadius: size * 0.02
                }}
              ></div>
              <div
                className="absolute"
                style={{
                  left: size * 0.08,
                  top: size * 0.7,
                  width: whiskerLength,
                  height: size * 0.02,
                  background: '#111827',
                  borderRadius: size * 0.02
                }}
              ></div>
              <div
                className="absolute"
                style={{
                  right: size * 0.08,
                  top: size * 0.62,
                  width: whiskerLength,
                  height: size * 0.02,
                  background: '#111827',
                  borderRadius: size * 0.02
                }}
              ></div>
              <div
                className="absolute"
                style={{
                  right: size * 0.08,
                  top: size * 0.7,
                  width: whiskerLength,
                  height: size * 0.02,
                  background: '#111827',
                  borderRadius: size * 0.02
                }}
              ></div>
            </div>
          );
        };

        const GameMenu = ({ onSelect, onClose }) => (
          <GameOverlay title="Sala de Juegos" onClose={onClose}>
            <p className="text-sm text-gray-600">
              Elige un minijuego para que tus gatitos se diviertan y suban su felicidad.
            </p>
            <div className="grid grid-cols-1 gap-4">
              {GAME_DEFINITIONS.map((game) => (
                <button
                  key={game.id}
                  onClick={() => onSelect(game.id)}
                  className="flex items-start space-x-3 rounded-2xl border border-purple-100 bg-purple-50 hover:bg-purple-100 transition p-4 text-left"
                >
                  <span className="text-3xl" aria-hidden="true">{game.emoji}</span>
                  <div>
                    <h3 className="text-base font-semibold text-purple-700">{game.title}</h3>
                    <p className="text-sm text-gray-600">{game.description}</p>
                  </div>
                </button>
              ))}
            </div>
          </GameOverlay>
        );

        const FlappyLukis = ({ onExit }) => {
          const GAME_WIDTH = 320;
          const GAME_HEIGHT = 420;
          const BIRD_SIZE = 46;
          const BIRD_X = 60;
          const OBSTACLE_WIDTH = 60;
          const GAP_HEIGHT = 130;

          const [bird, setBird] = useState({ y: GAME_HEIGHT / 2 - BIRD_SIZE / 2, velocity: 0 });
          const [obstacles, setObstacles] = useState(() => []);
          const [score, setScore] = useState(0);
          const [isRunning, setIsRunning] = useState(false);
          const [isGameOver, setIsGameOver] = useState(false);
          const loopRef = useRef(null);

          const createObstacle = useCallback((offset = 0) => {
            const gapTop = Math.random() * (GAME_HEIGHT - GAP_HEIGHT - 120) + 60;
            return {
              x: GAME_WIDTH + offset,
              gapTop,
              gapBottom: gapTop + GAP_HEIGHT,
              passed: false
            };
          }, []);

          const stopGame = useCallback(() => {
            setIsRunning(false);
            setIsGameOver(true);
          }, []);

          const resetGame = useCallback(() => {
            setBird({ y: GAME_HEIGHT / 2 - BIRD_SIZE / 2, velocity: 0 });
            setObstacles([createObstacle(), createObstacle(GAME_WIDTH / 2 + 140)]);
            setScore(0);
            setIsGameOver(false);
            setIsRunning(true);
          }, [createObstacle]);

          useEffect(() => {
            if (!isRunning) {
              if (loopRef.current) {
                clearInterval(loopRef.current);
                loopRef.current = null;
              }
              return;
            }

            loopRef.current = setInterval(() => {
              setBird((prev) => {
                const newVelocity = prev.velocity + 0.65;
                const newY = prev.y + newVelocity;
                return { y: newY, velocity: newVelocity };
              });

              setObstacles((prevObstacles) => {
                let scoreGain = 0;
                const updated = prevObstacles
                  .map((obstacle) => {
                    const newX = obstacle.x - 4;
                    let passed = obstacle.passed;
                    if (!passed && newX + OBSTACLE_WIDTH < BIRD_X) {
                      passed = true;
                      scoreGain += 1;
                    }
                    return { ...obstacle, x: newX, passed };
                  })
                  .filter((obstacle) => obstacle.x + OBSTACLE_WIDTH > -10);

                while (updated.length < 3) {
                  const last = updated[updated.length - 1];
                  const offset = last ? last.x + 180 : GAME_WIDTH;
                  updated.push(createObstacle(offset));
                }

                if (scoreGain > 0) {
                  setScore((prevScore) => prevScore + scoreGain);
                }

                return updated;
              });
            }, 40);

            return () => {
              if (loopRef.current) {
                clearInterval(loopRef.current);
                loopRef.current = null;
              }
            };
          }, [isRunning, createObstacle]);

          useEffect(() => {
            if (!isRunning) return;

            const birdTop = bird.y;
            const birdBottom = bird.y + BIRD_SIZE;

            if (birdBottom >= GAME_HEIGHT || birdTop <= 0) {
              stopGame();
              return;
            }

            for (const obstacle of obstacles) {
              if (
                obstacle.x < BIRD_X + BIRD_SIZE &&
                obstacle.x + OBSTACLE_WIDTH > BIRD_X
              ) {
                if (birdTop < obstacle.gapTop || birdBottom > obstacle.gapBottom) {
                  stopGame();
                  break;
                }
              }
            }
          }, [bird, obstacles, isRunning, stopGame]);

          const flap = useCallback(() => {
            if (!isRunning) return;
            setBird((prev) => ({ y: prev.y, velocity: -9.5 }));
          }, [isRunning]);

          useEffect(() => {
            const handleKey = (event) => {
              if (event.code === 'Space') {
                event.preventDefault();
                if (isGameOver) {
                  resetGame();
                } else {
                  flap();
                }
              }
            };
            window.addEventListener('keydown', handleKey);
            return () => window.removeEventListener('keydown', handleKey);
          }, [flap, isGameOver, resetGame]);

          useEffect(() => () => {
            if (loopRef.current) {
              clearInterval(loopRef.current);
            }
          }, []);

          return (
            <div className="space-y-4">
              <div className="flex items-center justify-between text-sm text-gray-600">
                <span>Puntuaci√≥n: <span className="font-semibold text-purple-600">{score}</span></span>
                <button
                  onClick={onExit}
                  className="px-3 py-1.5 text-xs font-semibold rounded-full bg-gray-200 hover:bg-gray-300 transition"
                >
                  Salir
                </button>
              </div>
              <div
                className="relative mx-auto rounded-3xl overflow-hidden shadow-inner"
                style={{ width: GAME_WIDTH, height: GAME_HEIGHT }}
              >
                <div
                  className="absolute inset-0 bg-gradient-to-b from-sky-200 via-sky-100 to-emerald-100"
                  onClick={flap}
                  onTouchStart={(event) => {
                    event.preventDefault();
                    flap();
                  }}
                >
                  {(() => {
                    const tilt = Math.max(Math.min(bird.velocity * 2.8, 35), -35);
                    return (
                      <div
                        className="absolute flex items-center justify-center"
                        style={{
                          left: `${BIRD_X}px`,
                          top: `${bird.y}px`,
                          width: `${BIRD_SIZE}px`,
                          height: `${BIRD_SIZE}px`,
                          transform: `rotate(${tilt}deg)`
                        }}
                      >
                        <LukisFace size={BIRD_SIZE} className="drop-shadow-lg" />
                      </div>
                    );
                  })()}
                  {obstacles.map((obstacle, index) => (
                    <React.Fragment key={index}>
                      <div
                        className="absolute bg-emerald-500 border-2 border-emerald-300 rounded-b-2xl"
                        style={{
                          left: `${obstacle.x}px`,
                          top: 0,
                          width: `${OBSTACLE_WIDTH}px`,
                          height: `${obstacle.gapTop}px`
                        }}
                      />
                      <div
                        className="absolute bg-emerald-500 border-2 border-emerald-300 rounded-t-2xl"
                        style={{
                          left: `${obstacle.x}px`,
                          top: `${obstacle.gapBottom}px`,
                          width: `${OBSTACLE_WIDTH}px`,
                          height: `${GAME_HEIGHT - obstacle.gapBottom}px`
                        }}
                      />
                    </React.Fragment>
                  ))}
                  {!isRunning && !isGameOver && (
                    <div className="absolute inset-0 flex flex-col items-center justify-center bg-white/70 text-center p-6 space-y-2">
                      <span className="text-4xl">üêæ</span>
                      <p className="text-base font-semibold text-purple-600">Pulsa para comenzar</p>
                      <p className="text-sm text-gray-600">Toca o presiona la barra espaciadora para que Lukis aletee.</p>
                      <button
                        onClick={resetGame}
                        className="mt-2 px-4 py-2 rounded-full bg-purple-500 text-white text-sm font-semibold hover:bg-purple-600 transition"
                      >
                        ¬°Empezar!
                      </button>
                    </div>
                  )}
                  {isGameOver && (
                    <div className="absolute inset-0 flex flex-col items-center justify-center bg-white/70 text-center p-6 space-y-2">
                      <span className="text-4xl">üí•</span>
                      <p className="text-base font-semibold text-purple-600">¬°Ups! Lukis se ha cansado.</p>
                      <p className="text-sm text-gray-600">Puntuaci√≥n final: {score}</p>
                      <div className="flex space-x-2">
                        <button
                          onClick={resetGame}
                          className="px-4 py-2 rounded-full bg-purple-500 text-white text-sm font-semibold hover:bg-purple-600 transition"
                        >
                          Intentar de nuevo
                        </button>
                        <button
                          onClick={onExit}
                          className="px-4 py-2 rounded-full bg-gray-200 text-sm font-semibold hover:bg-gray-300 transition"
                        >
                          Salir
                        </button>
                      </div>
                    </div>
                  )}
                </div>
              </div>
            </div>
          );
        };

        const LukisSkyJump = ({ onExit }) => {
          const GAME_WIDTH = 320;
          const GAME_HEIGHT = 480;
          const PLAYER_SIZE = 44;
          const GRAVITY = 0.55;
          const JUMP_FORCE = 11.5;
          const MOVE_SPEED = 4.2;

          const createInitialPlatforms = useCallback(() => {
            const basePlatforms = [];
            const step = GAME_HEIGHT / 6;
            for (let i = 0; i < 6; i += 1) {
              const width = Math.random() * 50 + 70;
              const x = Math.random() * (GAME_WIDTH - width);
              const y = GAME_HEIGHT - i * step - 60;
              basePlatforms.push({ x, y, width });
            }
            basePlatforms.push({
              x: GAME_WIDTH / 2 - 60,
              y: GAME_HEIGHT - 20,
              width: 120
            });
            return basePlatforms;
          }, []);

          const getInitialPlayer = useCallback(
            () => ({ x: GAME_WIDTH / 2 - PLAYER_SIZE / 2, y: GAME_HEIGHT - 140, vy: 0 }),
            []
          );

          const [player, setPlayer] = useState(() => getInitialPlayer());
          const [platforms, setPlatforms] = useState(() => createInitialPlatforms());
          const [score, setScore] = useState(0);
          const [isRunning, setIsRunning] = useState(false);
          const [isGameOver, setIsGameOver] = useState(false);
          const [activeDirection, setActiveDirection] = useState(null);

          const playerRef = useRef(player);
          const platformsRef = useRef(platforms);
          const scoreRef = useRef(score);
          const inputsRef = useRef({ left: false, right: false });
          const totalHeightRef = useRef(0);

          useEffect(() => {
            playerRef.current = player;
          }, [player]);

          useEffect(() => {
            platformsRef.current = platforms;
          }, [platforms]);

          useEffect(() => {
            scoreRef.current = score;
          }, [score]);

          const resetGame = useCallback(() => {
            const initialPlatforms = createInitialPlatforms();
            const initialPlayer = getInitialPlayer();
            totalHeightRef.current = 0;
            scoreRef.current = 0;
            inputsRef.current.left = false;
            inputsRef.current.right = false;
            setActiveDirection(null);
            setScore(0);
            setPlatforms(initialPlatforms);
            setPlayer(initialPlayer);
            platformsRef.current = initialPlatforms;
            playerRef.current = initialPlayer;
            setIsGameOver(false);
            setIsRunning(true);
          }, [createInitialPlatforms, getInitialPlayer]);

          useEffect(() => {
            if (!isRunning) {
              inputsRef.current.left = false;
              inputsRef.current.right = false;
              setActiveDirection(null);
            }
          }, [isRunning]);

          const handleControlStart = useCallback((direction) => {
            inputsRef.current[direction] = true;
            setActiveDirection(direction);
          }, []);

          const handleControlEnd = useCallback((direction) => {
            inputsRef.current[direction] = false;
            setActiveDirection((prev) => (prev === direction ? null : prev));
          }, []);

          useEffect(() => {
            const handleKeyDown = (event) => {
              if (event.code === 'ArrowLeft' || event.code === 'KeyA') {
                inputsRef.current.left = true;
                setActiveDirection('left');
              } else if (event.code === 'ArrowRight' || event.code === 'KeyD') {
                inputsRef.current.right = true;
                setActiveDirection('right');
              } else if (event.code === 'Space') {
                if (!isRunning) {
                  event.preventDefault();
                  resetGame();
                }
              }
            };

            const handleKeyUp = (event) => {
              if (event.code === 'ArrowLeft' || event.code === 'KeyA') {
                inputsRef.current.left = false;
                setActiveDirection((prev) => (prev === 'left' ? null : prev));
              } else if (event.code === 'ArrowRight' || event.code === 'KeyD') {
                inputsRef.current.right = false;
                setActiveDirection((prev) => (prev === 'right' ? null : prev));
              }
            };

            window.addEventListener('keydown', handleKeyDown);
            window.addEventListener('keyup', handleKeyUp);
            return () => {
              window.removeEventListener('keydown', handleKeyDown);
              window.removeEventListener('keyup', handleKeyUp);
            };
          }, [isRunning, resetGame]);

          const updateGame = useCallback(() => {
            const currentPlayer = playerRef.current;
            const currentPlatforms = platformsRef.current;
            let newVelocity = currentPlayer.vy + GRAVITY;
            let newX = currentPlayer.x;

            if (inputsRef.current.left) {
              newX -= MOVE_SPEED;
            }
            if (inputsRef.current.right) {
              newX += MOVE_SPEED;
            }

            if (newX < -PLAYER_SIZE / 2) {
              newX = GAME_WIDTH - PLAYER_SIZE / 2;
            } else if (newX > GAME_WIDTH - PLAYER_SIZE / 2) {
              newX = -PLAYER_SIZE / 2;
            }

            let newY = currentPlayer.y + newVelocity;
            const prevBottom = currentPlayer.y + PLAYER_SIZE;
            const nextBottom = newY + PLAYER_SIZE;

            for (const platform of currentPlatforms) {
              if (
                prevBottom <= platform.y &&
                nextBottom >= platform.y &&
                newX + PLAYER_SIZE > platform.x &&
                newX < platform.x + platform.width &&
                newVelocity > 0
              ) {
                newVelocity = -JUMP_FORCE;
                newY = platform.y - PLAYER_SIZE;
                break;
              }
            }

            let verticalShift = 0;
            const scrollThreshold = GAME_HEIGHT * 0.4;
            if (newY < scrollThreshold) {
              verticalShift = scrollThreshold - newY;
              newY = scrollThreshold;
            }

            let updatedPlatforms = currentPlatforms
              .map((platform) => ({ ...platform, y: platform.y + verticalShift }))
              .filter((platform) => platform.y < GAME_HEIGHT + 40);

            while (updatedPlatforms.length < 8) {
              const highestY = updatedPlatforms.reduce(
                (min, platform) => Math.min(min, platform.y),
                GAME_HEIGHT
              );
              const platformY = (Number.isFinite(highestY) ? highestY : GAME_HEIGHT) - (Math.random() * 80 + 60);
              const width = Math.random() * 50 + 70;
              updatedPlatforms.push({
                x: Math.random() * (GAME_WIDTH - width),
                y: platformY,
                width
              });
            }

            if (verticalShift > 0) {
              totalHeightRef.current += verticalShift;
              const computedScore = Math.max(
                scoreRef.current,
                Math.floor(totalHeightRef.current / 45)
              );
              if (computedScore !== scoreRef.current) {
                scoreRef.current = computedScore;
                setScore(computedScore);
              }
            }

            if (newY > GAME_HEIGHT) {
              setIsRunning(false);
              setIsGameOver(true);
              inputsRef.current.left = false;
              inputsRef.current.right = false;
              return;
            }

            const nextPlayer = { x: newX, y: newY, vy: newVelocity };
            playerRef.current = nextPlayer;
            platformsRef.current = updatedPlatforms;

            setPlayer(nextPlayer);
            setPlatforms(updatedPlatforms);
          }, []);

          useEffect(() => {
            if (!isRunning) return;
            const interval = setInterval(updateGame, 30);
            return () => clearInterval(interval);
          }, [isRunning, updateGame]);

          const tilt = Math.max(Math.min(player.vy * 1.8, 24), -24);

          return (
            <div className="space-y-4">
              <div className="flex items-center justify-between text-sm text-gray-600">
                <span>Altura: <span className="font-semibold text-purple-600">{score}</span></span>
                <button
                  onClick={onExit}
                  className="px-3 py-1.5 text-xs font-semibold rounded-full bg-gray-200 hover:bg-gray-300 transition"
                >
                  Salir
                </button>
              </div>
              <div
                className="relative mx-auto rounded-3xl overflow-hidden shadow-inner"
                style={{ width: GAME_WIDTH, height: GAME_HEIGHT }}
              >
                <div className="absolute inset-0 bg-gradient-to-b from-sky-200 via-slate-100 to-white">
                  {platforms.map((platform, index) => (
                    <div
                      key={index}
                      className="absolute bg-emerald-200 border border-emerald-400 rounded-2xl shadow-sm"
                      style={{
                        left: `${platform.x}px`,
                        top: `${platform.y}px`,
                        width: `${platform.width}px`,
                        height: '14px'
                      }}
                    ></div>
                  ))}
                  <div
                    className="absolute flex items-center justify-center transition-transform duration-75"
                    style={{
                      left: `${player.x}px`,
                      top: `${player.y}px`,
                      width: `${PLAYER_SIZE}px`,
                      height: `${PLAYER_SIZE}px`,
                      transform: `rotate(${tilt}deg)`
                    }}
                  >
                    <LukisFace size={PLAYER_SIZE} className="drop-shadow-lg" />
                  </div>
                  {!isRunning && !isGameOver && (
                    <div className="absolute inset-0 flex flex-col items-center justify-center bg-white/75 text-center p-6 space-y-3">
                      <span className="text-4xl">‚òÅÔ∏è</span>
                      <p className="text-base font-semibold text-purple-600">¬°Hora de saltar!</p>
                      <p className="text-sm text-gray-600">Usa las flechas, las teclas A/D o los botones para moverte.</p>
                      <button
                        onClick={resetGame}
                        className="px-4 py-2 rounded-full bg-purple-500 text-white text-sm font-semibold hover:bg-purple-600 transition"
                      >
                        ¬°A las nubes!
                      </button>
                    </div>
                  )}
                  {isGameOver && (
                    <div className="absolute inset-0 flex flex-col items-center justify-center bg-white/80 text-center p-6 space-y-3">
                      <span className="text-4xl">üåßÔ∏è</span>
                      <p className="text-base font-semibold text-purple-600">¬°Buen intento!</p>
                      <p className="text-sm text-gray-600">Altura alcanzada: {score}</p>
                      <div className="flex space-x-2">
                        <button
                          onClick={resetGame}
                          className="px-4 py-2 rounded-full bg-purple-500 text-white text-sm font-semibold hover:bg-purple-600 transition"
                        >
                          Intentar de nuevo
                        </button>
                        <button
                          onClick={onExit}
                          className="px-4 py-2 rounded-full bg-gray-200 text-sm font-semibold hover:bg-gray-300 transition"
                        >
                          Salir
                        </button>
                      </div>
                    </div>
                  )}
                </div>
              </div>
              <div className="flex items-center justify-center space-x-4">
                <button
                  type="button"
                  onMouseDown={() => handleControlStart('left')}
                  onMouseUp={() => handleControlEnd('left')}
                  onMouseLeave={() => handleControlEnd('left')}
                  onTouchStart={(event) => {
                    event.preventDefault();
                    handleControlStart('left');
                  }}
                  onTouchEnd={() => handleControlEnd('left')}
                  onTouchCancel={() => handleControlEnd('left')}
                  className={`px-5 py-3 text-lg font-semibold rounded-full border transition ${
                    activeDirection === 'left'
                      ? 'bg-purple-500 text-white border-purple-500'
                      : 'bg-white text-purple-600 border-purple-200 hover:border-purple-400'
                  }`}
                >
                  ‚óÄÔ∏é
                </button>
                <button
                  type="button"
                  onMouseDown={() => handleControlStart('right')}
                  onMouseUp={() => handleControlEnd('right')}
                  onMouseLeave={() => handleControlEnd('right')}
                  onTouchStart={(event) => {
                    event.preventDefault();
                    handleControlStart('right');
                  }}
                  onTouchEnd={() => handleControlEnd('right')}
                  onTouchCancel={() => handleControlEnd('right')}
                  className={`px-5 py-3 text-lg font-semibold rounded-full border transition ${
                    activeDirection === 'right'
                      ? 'bg-purple-500 text-white border-purple-500'
                      : 'bg-white text-purple-600 border-purple-200 hover:border-purple-400'
                  }`}
                >
                  ‚ñ∂Ô∏é
                </button>
              </div>
            </div>
          );
        };

        const SOUND_LIBRARY = {
          meow: {
            files: ['meow-1.mp3', 'meow_QO6VsE6.mp3', 'the-end-meow-by-nekocat-just-3-second-1.mp3'],
            volume: 0.6
          },
          purr: {
            files: ['cat-purr.mp3', 'little-puff-purr.mp3', 'little-puff-purr-brr.mp3'],
            volume: 0.45
          }
        };

        const ACTION_SOUNDS = {
          feed: ['meow', 'purr'],
          play: ['meow'],
          sleep: ['purr']
        };

        const REMINDER_DELAY_MS = 1000 * 60 * 90;
        const REMINDER_MIN_DELAY_MS = 1000 * 30;
        const REMINDER_SYNC_TAG = 'catagotchi-reminder';

        const sendMessageToServiceWorker = async (message) => {
          if (typeof navigator === 'undefined' || !navigator.serviceWorker) {
            return;
          }
          try {
            const registration = await navigator.serviceWorker.ready;
            const targets = [
              navigator.serviceWorker.controller,
              registration?.active,
              registration?.waiting,
              registration?.installing
            ].filter(Boolean);
            targets.forEach((worker) => {
              try {
                worker.postMessage(message);
              } catch (error) {
                console.warn('No se pudo enviar el mensaje al service worker', error);
              }
            });
          } catch (error) {
            console.warn('No se pudo comunicar con el service worker', error);
          }
        };

        const clamp = (value, min, max) => Math.min(Math.max(value, min), max);

        const createSoundController = () => {
          if (typeof Audio === 'undefined') {
            return null;
          }

          const pools = Object.entries(SOUND_LIBRARY).reduce((acc, [key, definition]) => {
            const { files = [], volume = 0.5 } = definition || {};
            const entries = files.filter(Boolean).map(src => {
              const element = new Audio(src);
              element.preload = 'auto';
              element.volume = volume;
              return { src, instances: [element], volume };
            });
            if (entries.length > 0) {
              acc[key] = entries;
            }
            return acc;
          }, {});

          const getInstance = (entry) => {
            if (!entry) return null;
            const available = entry.instances.find(audio => audio.paused);
            if (available) {
              return available;
            }
            const clone = entry.instances[0]?.cloneNode(true) || new Audio(entry.src);
            clone.volume = entry.volume;
            clone.preload = 'auto';
            entry.instances.push(clone);
            return clone;
          };

          const playEffect = (effectKey) => {
            const entries = pools[effectKey];
            if (!entries || entries.length === 0) return;
            const entry = entries[Math.floor(Math.random() * entries.length)];
            const audio = getInstance(entry);
            if (!audio) return;
            audio.currentTime = 0;
            const playback = audio.play();
            if (playback && typeof playback.catch === 'function') {
              playback.catch(() => {});
            }
          };

          const playForAction = (actionKey) => {
            const effects = ACTION_SOUNDS[actionKey];
            if (Array.isArray(effects) && effects.length > 0) {
              effects.forEach(effect => playEffect(effect));
            } else {
              playEffect(actionKey);
            }
          };

          return {
            playEffect,
            playForAction
          };
        };

        const CatTamagotchi = () => {
          const [gameState, setGameState] = useState({
            happiness: 75,
            energy: 60,
            hunger: 40,
            mood: 'content',
            lastInteraction: Date.now()
          });

          const [cats, setCats] = useState([
            {
              name: 'Lukis',
              type: 'tuxedo',
              position: { x: 25, y: 60 },
              direction: 1,
              actionState: 'idle',
              tilt: 0,
              bobOffset: 0,
              eyeColor: 'bg-amber-300'
            },
            {
              name: 'Arwen',
              type: 'gris',
              position: { x: 50, y: 70 },
              direction: -1,
              actionState: 'idle',
              tilt: 0,
              bobOffset: 0,
              eyeColor: 'bg-slate-200'
            },
            {
              name: 'Iria',
              type: 'siamese',
              position: { x: 75, y: 65 },
              direction: 1,
              actionState: 'idle',
              tilt: 0,
              bobOffset: 0,
              eyeColor: 'bg-blue-500'
            }
          ]);

          const [isAnimating, setIsAnimating] = useState(false);
          const [currentAction, setCurrentAction] = useState('');
          const [isGameMenuOpen, setIsGameMenuOpen] = useState(false);
          const [activeGame, setActiveGame] = useState(null);
          const [isNightTime, setIsNightTime] = useState(false);
          const [canInstall, setCanInstall] = useState(false);
          const [installStatus, setInstallStatus] = useState('');
          const [isStandalone, setIsStandalone] = useState(false);
          const [isIosDevice, setIsIosDevice] = useState(false);
          const notificationsSupported = typeof window !== 'undefined' && typeof Notification === 'function';
          const [notificationsEnabled, setNotificationsEnabled] = useState(false);
          const [notificationStatus, setNotificationStatus] = useState('');
          const soundControllerRef = useRef(typeof window !== 'undefined' ? createSoundController() : null);
          const installPromptRef = useRef(null);
          const installStatusTimeoutRef = useRef(null);
          const notificationStatusTimeoutRef = useRef(null);
          const reminderTimeoutRef = useRef(null);
          const primaryCatName = cats[0]?.name || 'Tu gatito';

          const openGameMenu = useCallback(() => {
            setIsGameMenuOpen(true);
            setActiveGame(null);
            setGameState((prev) => ({
              ...prev,
              happiness: clamp(prev.happiness + 5, 0, 100),
              lastInteraction: Date.now()
            }));
          }, []);

          const handleCloseMenu = useCallback(() => {
            setIsGameMenuOpen(false);
            setActiveGame(null);
          }, []);

          const handleSelectGame = useCallback((gameId) => {
            setActiveGame(gameId);
            setIsGameMenuOpen(false);
            setGameState((prev) => ({
              ...prev,
              happiness: clamp(prev.happiness + 8, 0, 100),
              energy: clamp(prev.energy - 5, 0, 100),
              lastInteraction: Date.now()
            }));
          }, []);

          const closeGameExperience = useCallback(() => {
            setActiveGame(null);
            setIsGameMenuOpen(false);
            setGameState((prev) => ({
              ...prev,
              happiness: clamp(prev.happiness + 3, 0, 100),
              lastInteraction: Date.now()
            }));
          }, []);

          const showInstallStatus = useCallback((message) => {
            setInstallStatus(message);
            if (installStatusTimeoutRef.current) {
              clearTimeout(installStatusTimeoutRef.current);
            }
            installStatusTimeoutRef.current = setTimeout(() => {
              setInstallStatus('');
              installStatusTimeoutRef.current = null;
            }, 6000);
          }, []);

          const showNotificationStatus = useCallback((message) => {
            setNotificationStatus(message);
            if (notificationStatusTimeoutRef.current) {
              clearTimeout(notificationStatusTimeoutRef.current);
            }
            notificationStatusTimeoutRef.current = setTimeout(() => {
              setNotificationStatus('');
              notificationStatusTimeoutRef.current = null;
            }, 6000);
          }, []);

          const updateBackgroundReminderRegistration = useCallback(
            async (enabled, lastInteraction) => {
              if (!notificationsSupported || typeof navigator === 'undefined' || !navigator.serviceWorker) {
                return;
              }
              try {
                const registration = await navigator.serviceWorker.ready;
                const supportsPeriodicSync = 'periodicSync' in registration;
                const permissionGranted = Notification.permission === 'granted';
                const shouldEnable = Boolean(enabled && permissionGranted);

                if (supportsPeriodicSync) {
                  try {
                    const tags = await registration.periodicSync.getTags();
                    const alreadyRegistered = tags.includes(REMINDER_SYNC_TAG);
                    if (shouldEnable && !alreadyRegistered) {
                      await registration.periodicSync.register(REMINDER_SYNC_TAG, { minInterval: REMINDER_DELAY_MS });
                    } else if (!shouldEnable && alreadyRegistered) {
                      await registration.periodicSync.unregister(REMINDER_SYNC_TAG);
                    }
                  } catch (error) {
                    console.warn('No se pudo actualizar el registro de recordatorios en segundo plano', error);
                  }
                }

                const payload = {
                  enabled: shouldEnable,
                  name: primaryCatName,
                  url: typeof window !== 'undefined' ? window.location.href : './'
                };
                if (typeof lastInteraction === 'number' && Number.isFinite(lastInteraction)) {
                  payload.lastInteraction = lastInteraction;
                }

                await sendMessageToServiceWorker({ type: 'REMINDER_UPDATE', payload });
              } catch (error) {
                console.warn('No se pudo sincronizar la configuraci√≥n de recordatorios', error);
              }
            },
            [notificationsSupported, primaryCatName]
          );

          const showReminderNotification = useCallback(async () => {
            if (!notificationsEnabled || !notificationsSupported || Notification.permission !== 'granted') {
              return;
            }
            const catName = primaryCatName;
            const title = `¬°${catName} te echa de menos!`;
            const body = `${catName} quiere que vuelvas a jugar un ratito.`;
            const options = {
              body,
              icon: 'icons/caticon/icon.png',
              badge: 'icons/caticon/icon.png',
              tag: 'catagotchi-recordatorio',
              renotify: true,
              data: { url: typeof window !== 'undefined' ? window.location.href : './' }
            };
            try {
              if (typeof navigator !== 'undefined' && navigator.serviceWorker) {
                const registration = await navigator.serviceWorker.ready;
                if (registration?.showNotification) {
                  await registration.showNotification(title, options);
                } else {
                  new Notification(title, options);
                }
              } else {
                new Notification(title, options);
              }
            } catch (error) {
              console.error('No se pudo mostrar el recordatorio', error);
            } finally {
              const now = Date.now();
              setGameState((prev) => ({ ...prev, lastInteraction: now }));
              updateBackgroundReminderRegistration(true, now);
            }
          }, [notificationsEnabled, notificationsSupported, primaryCatName, updateBackgroundReminderRegistration]);

          const handleToggleNotifications = useCallback(async () => {
            if (!notificationsSupported) {
              showNotificationStatus('Tu dispositivo no admite notificaciones.');
              return;
            }
            if (notificationsEnabled) {
              setNotificationsEnabled(false);
              showNotificationStatus('Recordatorios en pausa.');
              await updateBackgroundReminderRegistration(false, Date.now());
              return;
            }
            let permission = Notification.permission;
            if (permission === 'default') {
              try {
                permission = await Notification.requestPermission();
              } catch (error) {
                permission = Notification.permission;
              }
            }
            if (permission !== 'granted') {
              setNotificationsEnabled(false);
              showNotificationStatus('Activa las notificaciones desde los ajustes del navegador.');
              await updateBackgroundReminderRegistration(false, Date.now());
              return;
            }
            const now = Date.now();
            setNotificationsEnabled(true);
            setGameState((prev) => ({ ...prev, lastInteraction: now }));
            showNotificationStatus(`${primaryCatName} te avisar√° cuando necesite mimos.`);
            await updateBackgroundReminderRegistration(true, now);
          }, [notificationsSupported, notificationsEnabled, showNotificationStatus, updateBackgroundReminderRegistration, primaryCatName]);

          const playActionSound = useCallback((actionKey) => {
            const controller = soundControllerRef.current;
            if (!controller) return;
            controller.playForAction(actionKey);
          }, []);

          useEffect(() => {
            if (typeof window === 'undefined') {
              return undefined;
            }
            setIsIosDevice(/iphone|ipad|ipod/i.test(window.navigator.userAgent || ''));
            return () => {
              if (installStatusTimeoutRef.current) {
                clearTimeout(installStatusTimeoutRef.current);
              }
              if (notificationStatusTimeoutRef.current) {
                clearTimeout(notificationStatusTimeoutRef.current);
              }
              if (reminderTimeoutRef.current) {
                clearTimeout(reminderTimeoutRef.current);
              }
            };
          }, []);

          useEffect(() => {
            if (typeof navigator !== 'undefined' && 'serviceWorker' in navigator) {
              navigator.serviceWorker.register('./service-worker.js').catch(() => {});
            }
          }, []);

          useEffect(() => {
            if (!notificationsSupported) {
              return;
            }
            if (notificationsEnabled && Notification.permission !== 'granted') {
              setNotificationsEnabled(false);
              updateBackgroundReminderRegistration(false, Date.now());
            }
          }, [notificationsEnabled, notificationsSupported, updateBackgroundReminderRegistration]);

          useEffect(() => {
            if (typeof window === 'undefined' || !notificationsSupported) {
              return;
            }
            try {
              const stored = window.localStorage.getItem('catagotchi-reminders');
              if (stored === 'on' && Notification.permission === 'granted') {
                setNotificationsEnabled(true);
              }
            } catch (error) {
              console.warn('No se pudo restaurar la configuraci√≥n de recordatorios', error);
            }
          }, [notificationsSupported]);

          useEffect(() => {
            if (typeof window === 'undefined') {
              return;
            }
            try {
              window.localStorage.setItem('catagotchi-reminders', notificationsEnabled ? 'on' : 'off');
            } catch (error) {
              console.warn('No se pudo guardar la configuraci√≥n de recordatorios', error);
            }
          }, [notificationsEnabled]);

          useEffect(() => {
            if (!notificationsEnabled || !notificationsSupported || Notification.permission !== 'granted') {
              if (reminderTimeoutRef.current) {
                clearTimeout(reminderTimeoutRef.current);
                reminderTimeoutRef.current = null;
              }
              return;
            }
            const now = Date.now();
            const lastInteraction = gameState.lastInteraction || now;
            const elapsed = now - lastInteraction;
            const delay = Math.max(REMINDER_MIN_DELAY_MS, REMINDER_DELAY_MS - elapsed);
            if (reminderTimeoutRef.current) {
              clearTimeout(reminderTimeoutRef.current);
            }
            reminderTimeoutRef.current = setTimeout(() => {
              reminderTimeoutRef.current = null;
              showReminderNotification();
            }, delay);

            return () => {
              if (reminderTimeoutRef.current) {
                clearTimeout(reminderTimeoutRef.current);
                reminderTimeoutRef.current = null;
              }
            };
          }, [notificationsEnabled, notificationsSupported, gameState.lastInteraction, showReminderNotification]);

          useEffect(() => {
            updateBackgroundReminderRegistration(notificationsEnabled, gameState.lastInteraction);
          }, [notificationsEnabled, gameState.lastInteraction, updateBackgroundReminderRegistration]);

          useEffect(() => {
            if (typeof window === 'undefined') {
              return undefined;
            }
            const updateTimeOfDay = () => {
              const hour = new Date().getHours();
              setIsNightTime(hour < 6 || hour >= 20);
            };
            updateTimeOfDay();
            const timeInterval = setInterval(updateTimeOfDay, 60000);
            return () => clearInterval(timeInterval);
          }, []);

          useEffect(() => {
            if (typeof window === 'undefined') {
              return undefined;
            }
            const handleBeforeInstallPrompt = (event) => {
              event.preventDefault();
              installPromptRef.current = event;
              setCanInstall(true);
            };

            const handleAppInstalled = () => {
              installPromptRef.current = null;
              setCanInstall(false);
              setIsStandalone(true);
              showInstallStatus('Catagotchi est√° en tu pantalla de inicio üêæ');
            };

            window.addEventListener('beforeinstallprompt', handleBeforeInstallPrompt);
            window.addEventListener('appinstalled', handleAppInstalled);

            return () => {
              window.removeEventListener('beforeinstallprompt', handleBeforeInstallPrompt);
              window.removeEventListener('appinstalled', handleAppInstalled);
            };
          }, [showInstallStatus]);

          useEffect(() => {
            if (typeof window === 'undefined' || typeof window.matchMedia !== 'function') {
              return undefined;
            }
            const mediaQuery = window.matchMedia('(display-mode: standalone)');

            const updateStandalone = () => {
              const navigatorStandalone =
                typeof window.navigator !== 'undefined' && 'standalone' in window.navigator
                  ? window.navigator.standalone
                  : false;
              const standalone = mediaQuery.matches || Boolean(navigatorStandalone);
              setIsStandalone(standalone);
            };

            updateStandalone();

            if (typeof mediaQuery.addEventListener === 'function') {
              mediaQuery.addEventListener('change', updateStandalone);
            } else if (typeof mediaQuery.addListener === 'function') {
              mediaQuery.addListener(updateStandalone);
            }

            return () => {
              if (typeof mediaQuery.removeEventListener === 'function') {
                mediaQuery.removeEventListener('change', updateStandalone);
              } else if (typeof mediaQuery.removeListener === 'function') {
                mediaQuery.removeListener(updateStandalone);
              }
            };
          }, []);

          useEffect(() => {
            const moveInterval = setInterval(() => {
              if (gameState.mood === 'tired' || isAnimating) return;
              setCats(prevCats =>
                prevCats.map(cat => {
                  const step = Math.random() * 4 + 2;
                  let newX = cat.position.x + cat.direction * step;
                  let newDirection = cat.direction;
                  if (newX <= 12) {
                    newX = 12;
                    newDirection = 1;
                  } else if (newX >= 88) {
                    newX = 88;
                    newDirection = -1;
                  }
                  if (Math.random() < 0.25) {
                    newDirection *= -1;
                  }
                  const newY = clamp(cat.position.y + (Math.random() - 0.5) * 4, 55, 78);
                  const tilt = clamp((Math.random() - 0.5) * 12, -8, 8);
                  const bobOffset = clamp((Math.random() - 0.5) * 8, -4, 4);
                  return {
                    ...cat,
                    position: { x: newX, y: newY },
                    direction: newDirection,
                    tilt,
                    bobOffset
                  };
                })
              );
            }, 1400);
            return () => clearInterval(moveInterval);
          }, [gameState.mood, isAnimating]);

          useEffect(() => {
            const interval = setInterval(() => {
              setGameState(prevState => {
                const newHunger = Math.max(0, prevState.hunger - 5);
                const newEnergy = Math.max(0, prevState.energy - 5);
                const newHappiness = Math.max(0, prevState.happiness - 5);
                let mood = 'content';
                if (newHappiness > 70 && newEnergy > 70 && newHunger > 70) mood = 'happy';
                else if (newHappiness > 50 && newEnergy > 50 && newHunger > 50) mood = 'content';
                else if (newHunger < 30) mood = 'hungry';
                else if (newEnergy < 30) mood = 'tired';
                else if (newHappiness < 30) mood = 'sad';
                return {
                  ...prevState,
                  hunger: newHunger,
                  energy: newEnergy,
                  happiness: newHappiness,
                  mood
                };
              });
            }, 3000);
            return () => clearInterval(interval);
          }, []);

          const handleAction = (action) => {
            if (isAnimating) return;
            setIsAnimating(true);
            setCurrentAction(action);
            playActionSound(action);
            setCats(prevCats =>
              prevCats.map(cat => ({
                ...cat,
                actionState: action
              }))
            );
            setTimeout(() => {
              setGameState(prevState => {
                let newState = { ...prevState, lastInteraction: Date.now() };
                switch (action) {
                  case 'feed':
                    newState.hunger = Math.min(100, prevState.hunger + 30);
                    newState.happiness = Math.min(100, prevState.happiness + 15);
                    break;
                  case 'play':
                    newState.energy = Math.max(20, prevState.energy - 15);
                    newState.happiness = Math.min(100, prevState.happiness + 25);
                    newState.hunger = Math.max(0, prevState.hunger - 10);
                    break;
                  case 'sleep':
                    newState.energy = Math.min(100, prevState.energy + 40);
                    newState.hunger = Math.max(0, prevState.hunger - 5);
                    break;
                  default:
                    break;
                }
                if (newState.happiness > 70 && newState.energy > 70 && newState.hunger > 70) newState.mood = 'happy';
                else if (newState.happiness > 50 && newState.energy > 50 && newState.hunger > 50) newState.mood = 'content';
                else if (newState.hunger < 30) newState.mood = 'hungry';
                else if (newState.energy < 30) newState.mood = 'tired';
                else if (newState.happiness < 30) newState.mood = 'sad';
                else newState.mood = 'content';
                return newState;
              });
              setCats(prevCats => 
                prevCats.map(cat => ({
                  ...cat,
                  actionState: 'idle'
                }))
              );
              setIsAnimating(false);
              setCurrentAction('');
            }, 2500);
          };

          const handleInstallClick = useCallback(async () => {
            if (installPromptRef.current) {
              try {
                installPromptRef.current.prompt();
                const choice = await installPromptRef.current.userChoice;
                if (choice?.outcome === 'accepted') {
                  showInstallStatus('¬°Listo! Busca Catagotchi en tu pantalla de inicio.');
                } else {
                  showInstallStatus('Puedes a√±adir Catagotchi m√°s tarde desde el men√∫ de tu navegador.');
                }
              } catch (error) {
                showInstallStatus('No se pudo completar la instalaci√≥n. Int√©ntalo de nuevo m√°s tarde.');
              } finally {
                installPromptRef.current = null;
                setCanInstall(false);
              }
              return;
            }

            if (isIosDevice) {
              showInstallStatus('Pulsa el bot√≥n Compartir y elige "A√±adir a pantalla de inicio".');
            } else {
              showInstallStatus('Busca "A√±adir a pantalla de inicio" en el men√∫ de tu navegador.');
            }
          }, [isIosDevice, showInstallStatus]);

          const shouldShowInstallButton = !isStandalone && (canInstall || isIosDevice);

          const getStatColor = (value) => {
            if (value > 70) return 'bg-green-500';
            if (value > 40) return 'bg-yellow-500';
            return 'bg-red-500';
          };

          const getMoodEmoji = (mood) => {
            switch (mood) {
              case 'happy': return 'üò∏';
              case 'content': return 'üò∫';
              case 'hungry': return 'üôÄ';
              case 'tired': return 'üò¥';
              case 'sad': return 'üòø';
              default: return 'üò∏';
            }
          };

          const getCatDisplay = (cat) => {
            const transformParts = ['translate(-50%, -50%)'];
            if (cat.direction < 0) transformParts.push('scaleX(-1)');
            if (cat.bobOffset) transformParts.push(`translateY(${cat.bobOffset}px)`);
            if (cat.tilt) transformParts.push(`rotate(${cat.tilt}deg)`);
            const transform = transformParts.join(' ');
            let extraElements = null;
            const avgStats = (gameState.happiness + gameState.energy + gameState.hunger) / 3;

            switch (cat.actionState) {
              case 'feed':
                extraElements = (
                  <div className="absolute -top-8 left-1/2 transform -translate-x-1/2">
                    <div className="text-lg animate-bounce">ü•õ</div>
                  </div>
                );
                break;
              case 'play':
                extraElements = (
                  <div className="absolute -top-8 left-1/2 transform -translate-x-1/2">
                    <div className="text-lg animate-pulse">üê≠</div>
                  </div>
                );
                break;
              case 'sleep':
                extraElements = (
                  <div className="absolute -top-6 left-1/2 transform -translate-x-1/2">
                    <div className="text-lg animate-pulse">üí§</div>
                  </div>
                );
                break;
              default:
                if (avgStats < 60) {
                  let angerEmoji = null;
                  if (avgStats < 20) angerEmoji = 'üò°';
                  else if (avgStats < 40) angerEmoji = 'üò†';
                  else angerEmoji = 'üò§';
                  extraElements = (
                    <div className="absolute -top-6 left-1/2 transform -translate-x-1/2">
                      <div className="text-lg animate-bounce">{angerEmoji}</div>
                    </div>
                  );
                }
                break;
            }

            const CatBody = ({ type, eyeColorClass }) => {
              const colors = {
                tuxedo: { body: 'bg-gray-900', chest: 'bg-white', ears: 'bg-gray-900' },
                gris: { body: 'bg-gray-400', chest: 'bg-white', ears: 'bg-gray-400' },
                siamese: { body: 'bg-yellow-100', face: 'bg-amber-800', ears: 'bg-amber-800' }
              }[type];

              const isSleeping = cat.actionState === 'sleep';
              const resolvedEyeClass =
                eyeColorClass ||
                (type === 'siamese' ? 'bg-blue-500' : type === 'gris' ? 'bg-blue-400' : 'bg-green-400');

              return (
                <div className="relative w-16 h-16">
                  <div className={`absolute bottom-0 left-2 w-12 h-12 ${colors.body} rounded-full`}></div>
                  {(type === 'tuxedo' || type === 'gris') && (
                    <div className={`absolute bottom-1 left-4 w-8 h-9 ${colors.chest} rounded-full`}></div>
                  )}
                  <div className={`absolute top-0 left-2 w-12 h-12 ${colors.body} rounded-full`}></div>
                  {type === 'siamese' ? (
                    <div className={`absolute top-1 left-3 w-10 h-9 ${colors.face} rounded-full`}></div>
                  ) : (
                    <div className="absolute top-1 left-4 w-7 h-7 transform rotate-180">
                      <div className="relative w-full h-full">
                        <div className="absolute bottom-0 left-1/2 w-4 h-4 bg-white rounded-[45%] transform -translate-x-1/2 rotate-45"></div>
                        <div className="absolute -top-2 left-0 w-3.5 h-3.5 bg-white rounded-full"></div>
                        <div className="absolute top-0 -left-2 w-3.5 h-3.5 bg-white rounded-full"></div>
                      </div>
                    </div>
                  )}
                  <div className={`absolute -top-1 left-3 w-4 h-5 ${colors.ears} rounded-full transform -rotate-12`}></div>
                  <div className={`absolute -top-1 right-3 w-4 h-5 ${colors.ears} rounded-full transform rotate-12`}></div>
                  <div className="absolute top-0 left-4 w-2 h-3 bg-pink-300 rounded-full transform -rotate-12"></div>
                  <div className="absolute top-0 right-4 w-2 h-3 bg-pink-300 rounded-full transform rotate-12"></div>
                  {isSleeping ? (
                    <>
                      <div className="absolute top-4 left-4 w-2 h-1 bg-gray-800 rounded-full"></div>
                      <div className="absolute top-4 right-4 w-2 h-1 bg-gray-800 rounded-full"></div>
                    </>
                  ) : (
                    <>
                      <div className={`absolute top-4 left-4 w-2 h-2 ${resolvedEyeClass} rounded-full`}></div>
                      <div className={`absolute top-4 right-4 w-2 h-2 ${resolvedEyeClass} rounded-full`}></div>
                    </>
                  )}
                  <div className="absolute top-5 left-1/2 transform -translate-x-1/2 w-1 h-1 bg-pink-400 rounded-full"></div>
                  <div className={`absolute -right-1 bottom-3 w-3 h-8 ${colors.body} rounded-full transform rotate-45`}></div>
                  <div className={`absolute bottom-0 left-3 w-1.5 h-4 ${type === 'siamese' ? 'bg-amber-800' : colors.body} rounded-full`}></div>
                  <div className={`absolute bottom-0 right-3 w-1.5 h-4 ${type === 'siamese' ? 'bg-amber-800' : colors.body} rounded-full`}></div>
                </div>
              );
            };

            return (
              <div
                className="absolute transition-all duration-1000"
                style={{ left: `${cat.position.x}%`, top: `${cat.position.y}%`, transform }}
              >
                <CatBody type={cat.type} eyeColorClass={cat.eyeColor} />
                {extraElements}
              </div>
            );
          };

          const activeGameDefinition = activeGame
            ? GAME_DEFINITIONS.find((game) => game.id === activeGame)
            : null;

          return (
            <div className="min-h-screen bg-gradient-to-br from-purple-400 via-pink-300 to-yellow-300 p-4">
              <div className="max-w-md mx-auto bg-white rounded-3xl shadow-2xl overflow-hidden">
                <div className="bg-gradient-to-r from-purple-500 to-pink-500 p-4 text-white text-center">
                  <h1 className="text-2xl font-bold">üê± Los Tres Gatitos üê±</h1>
                  <p className="text-sm opacity-90">Lukis, Arwen e Iria</p>
                </div>

                <div className={`relative h-64 ${isNightTime ? 'bg-gradient-to-b from-indigo-900 to-purple-900' : 'bg-gradient-to-b from-blue-100 to-green-200'} overflow-hidden transition-all duration-1000`}>
                  <div className="absolute bottom-0 w-full h-12 bg-amber-200"></div>
                  <div className="absolute left-0 top-0 w-2 h-full bg-amber-300"></div>
                  <div className="absolute right-0 top-0 w-2 h-full bg-amber-300"></div>
                  <div className="absolute top-0 w-full h-2 bg-amber-300"></div>

                  <div className="absolute top-4 right-4 w-24 h-20 bg-sky-200 border-4 border-amber-600 rounded">
                    <div className={`absolute inset-1 ${isNightTime ? 'bg-indigo-900' : 'bg-sky-100'} transition-all duration-1000`}>
                      <div className="w-full h-0.5 bg-amber-600 absolute top-1/2 transform -translate-y-1/2"></div>
                      <div className="h-full w-0.5 bg-amber-600 absolute left-1/2 transform -translate-x-1/2"></div>
                      {isNightTime ? (
                        <>
                          <div className="absolute top-2 right-2 w-6 h-6 bg-yellow-100 rounded-full shadow-lg"></div>
                          <div className="absolute top-1 left-2 text-yellow-200 text-xs">‚ú¶</div>
                        </>
                      ) : (
                        <>
                          <div className="absolute top-2 left-2 w-8 h-8 bg-yellow-400 rounded-full animate-pulse"></div>
                          <div className="absolute top-1 right-1 w-4 h-2 bg-white rounded-full opacity-70"></div>
                        </>
                      )}
                    </div>
                    <div className="absolute -top-1 -left-2 w-5 h-20 bg-pink-300 rounded-r-lg"></div>
                    <div className="absolute -top-1 -right-2 w-5 h-20 bg-pink-300 rounded-l-lg"></div>
                  </div>

                  <div className="absolute bottom-12 left-4 w-12 h-6 bg-red-400 rounded-full border-2 border-red-500"></div>
                  <div className="absolute bottom-12 right-8 w-6 h-3 bg-gray-300 rounded-full border border-gray-400"></div>
                  <div className="absolute bottom-12 right-16 w-6 h-3 bg-gray-300 rounded-full border border-gray-400"></div>
                  <div className="absolute bottom-12 right-24 w-6 h-3 bg-gray-300 rounded-full border border-gray-400"></div>
                  <div className="absolute bottom-12 left-1/4 w-36 h-10 bg-purple-300 rounded-lg opacity-60"></div>

                  {cats.map((cat, index) => (
                    <div key={index}>{getCatDisplay(cat)}</div>
                  ))}
                </div>

                <div className="p-4 text-center bg-gray-50">
                  <div className="flex justify-center items-center space-x-2 mb-2">
                    <span className="text-lg">{getMoodEmoji(gameState.mood)}</span>
                    <span className="text-sm text-gray-600 capitalize">
                      Estado: {gameState.mood === 'happy' ? 'Felices' : 
                             gameState.mood === 'content' ? 'Tranquilos' :
                             gameState.mood === 'hungry' ? 'Hambrientos' :
                             gameState.mood === 'tired' ? 'Cansados' :
                             gameState.mood === 'sad' ? 'Tristes' : 'Juguetones'}
                    </span>
                  </div>
                  <div className="flex justify-center items-center space-x-2">
                    <span className="text-base" role="img" aria-hidden="true">
                      {isNightTime ? 'üåô' : '‚òÄÔ∏è'}
                    </span>
                    <span className="text-xs text-gray-500">
                      {isNightTime ? 'Hora de dormir' : 'D√≠a activo'}
                    </span>
                  </div>
                </div>

                <div className="px-6 pb-6 space-y-3">
                  <div className="flex items-center space-x-3">
                    <span className="text-red-500 text-xl" role="img" aria-hidden="true">‚ù§Ô∏è</span>
                    <div className="flex-1">
                      <div className="flex justify-between text-sm mb-1">
                        <span className="font-medium">Felicidad</span>
                        <span>{Math.round(gameState.happiness)}%</span>
                      </div>
                      <div className="w-full bg-gray-200 rounded-full h-2">
                        <div
                          className={`h-2 rounded-full transition-all duration-500 ${getStatColor(gameState.happiness)}`}
                          style={{ width: `${gameState.happiness}%` }}
                        ></div>
                      </div>
                    </div>
                  </div>

                  <div className="flex items-center space-x-3">
                    <span className="text-green-500 text-xl" role="img" aria-hidden="true">üîã</span>
                    <div className="flex-1">
                      <div className="flex justify-between text-sm mb-1">
                        <span className="font-medium">Energ√≠a</span>
                        <span>{Math.round(gameState.energy)}%</span>
                      </div>
                      <div className="w-full bg-gray-200 rounded-full h-2">
                        <div
                          className={`h-2 rounded-full transition-all duration-500 ${getStatColor(gameState.energy)}`}
                          style={{ width: `${gameState.energy}%` }}
                        ></div>
                      </div>
                    </div>
                  </div>

                  <div className="flex items-center space-x-3">
                    <span className="text-yellow-600 text-xl" role="img" aria-hidden="true">üçó</span>
                    <div className="flex-1">
                      <div className="flex justify-between text-sm mb-1">
                        <span className="font-medium">Hambre</span>
                        <span>{Math.round(gameState.hunger)}%</span>
                      </div>
                      <div className="w-full bg-gray-200 rounded-full h-2">
                        <div
                          className={`h-2 rounded-full transition-all duration-500 ${
                            gameState.hunger < 30 ? 'bg-red-500' :
                            gameState.hunger < 60 ? 'bg-yellow-500' : 'bg-green-500'
                          }`}
                          style={{ width: `${gameState.hunger}%` }}
                        ></div>
                      </div>
                    </div>
                  </div>
                </div>

                <div className="p-6 bg-gray-50 flex flex-wrap justify-center gap-4">
                  <button
                    onClick={() => handleAction('feed')}
                    disabled={isAnimating}
                    className="flex flex-col items-center space-y-2 px-4 py-3 bg-green-500 hover:bg-green-600 disabled:bg-gray-400 text-white rounded-2xl transition-all duration-300 transform hover:scale-105 disabled:scale-100"
                  >
                    <span className="text-2xl" role="img" aria-hidden="true">üç≤</span>
                    <span className="text-xs font-medium">Comer</span>
                  </button>

                  <button
                    onClick={() => handleAction('play')}
                    disabled={isAnimating}
                    className="flex flex-col items-center space-y-2 px-4 py-3 bg-blue-500 hover:bg-blue-600 disabled:bg-gray-400 text-white rounded-2xl transition-all duration-300 transform hover:scale-105 disabled:scale-100"
                  >
                    <span className="text-2xl" role="img" aria-hidden="true">üß∂</span>
                    <span className="text-xs font-medium">Jugar</span>
                  </button>

                  <button
                    onClick={() => handleAction('sleep')}
                    disabled={isAnimating}
                    className="flex flex-col items-center space-y-2 px-4 py-3 bg-purple-500 hover:bg-purple-600 disabled:bg-gray-400 text-white rounded-2xl transition-all duration-300 transform hover:scale-105 disabled:scale-100"
                  >
                    <span className="text-2xl" role="img" aria-hidden="true">üåô</span>
                    <span className="text-xs font-medium">Dormir</span>
                  </button>
                  <button
                    onClick={() => {
                      playActionSound('play');
                      openGameMenu();
                    }}
                    className="flex flex-col items-center space-y-2 px-4 py-3 bg-amber-500 hover:bg-amber-600 text-white rounded-2xl transition-all duration-300 transform hover:scale-105"
                  >
                    <span className="text-2xl" role="img" aria-hidden="true">üéÆ</span>
                    <span className="text-xs font-medium">Juegos</span>
                  </button>
                </div>

                {notificationsSupported && (
                  <div className="px-6 pb-4">
                    <button
                      onClick={handleToggleNotifications}
                      className={`w-full flex items-center justify-center space-x-2 px-4 py-3 rounded-2xl transition-all duration-300 text-white ${
                        notificationsEnabled ? 'bg-amber-500 hover:bg-amber-600' : 'bg-amber-400 hover:bg-amber-500'
                      }`}
                    >
                      <span className="text-xl" role="img" aria-hidden="true">{notificationsEnabled ? 'üîï' : 'üîî'}</span>
                      <span className="text-sm font-semibold">
                        {notificationsEnabled ? 'Pausar recordatorios' : 'Activar recordatorios'}
                      </span>
                    </button>
                    {!notificationsEnabled && !isStandalone && Notification?.permission !== 'granted' && (
                      <p className="mt-3 text-xs text-center text-gray-600">
                        A√±ade Catagotchi a tu pantalla de inicio para que los recordatorios funcionen mejor.
                      </p>
                    )}
                    {notificationStatus && (
                      <div className="mt-3 bg-amber-50 border border-amber-200 text-amber-700 text-sm rounded-2xl px-4 py-3 text-center">
                        {notificationStatus}
                      </div>
                    )}
                  </div>
                )}

                {installStatus && (
                  <div className="px-6 pb-4">
                    <div className="bg-pink-50 border border-pink-200 text-pink-700 text-sm rounded-2xl px-4 py-3 text-center">
                      {installStatus}
                    </div>
                  </div>
                )}

                {shouldShowInstallButton && (
                  <div className="px-6 pb-6">
                    <button
                      onClick={handleInstallClick}
                      className="w-full flex items-center justify-center space-x-2 px-4 py-3 bg-pink-500 hover:bg-pink-600 text-white rounded-2xl transition-all duration-300"
                    >
                      <span className="text-xl" role="img" aria-hidden="true">üì≤</span>
                      <span className="text-sm font-semibold">Guardar en pantalla de inicio</span>
                    </button>
                    {isIosDevice && !canInstall && (
                      <p className="mt-3 text-xs text-center text-gray-600">
                        En iPhone o iPad abre el men√∫ de compartir y toca ¬´A√±adir a pantalla de inicio¬ª.
                      </p>
                    )}
                  </div>
                )}

                {currentAction && (
                  <div className="px-6 pb-6">
                    <div className="bg-purple-100 text-purple-700 rounded-2xl p-3 text-center text-sm font-medium animate-pulse">
                      Ejecutando acci√≥n: {currentAction === 'feed' ? 'Comer' : currentAction === 'play' ? 'Jugar' : 'Dormir'}...
                    </div>
                  </div>
                )}
              </div>
              {isGameMenuOpen && (
                <GameMenu onSelect={handleSelectGame} onClose={handleCloseMenu} />
              )}
              {activeGame && activeGameDefinition && (
                <GameOverlay title={activeGameDefinition.title} onClose={closeGameExperience}>
                  {activeGame === 'flappy-lukis' && <FlappyLukis onExit={closeGameExperience} />}
                  {activeGame === 'lukis-sky-jump' && <LukisSkyJump onExit={closeGameExperience} />}
                </GameOverlay>
              )}
          </div>
        );
        };

        ReactDOM.createRoot(document.getElementById('root')).render(<CatTamagotchi />);
    </script>
</body>
</html>
